---
layout: post
title: Continuation Passing Style
tags: [程序理论, scheme, lisp]
comments: true
---

调用函数时，我们需要适当地记录函数调用处的信息，以便函数返回时可以从调用处继续执行。
大部分主流语言使用**存储返回地址的栈（stack）**来维护函数调用信息。

然而，栈是程序语言实现函数调用的方式，并不是程序语言的一部分。
因此，程序员并不能通过操作栈来控制程序的执行过程（也许 C 语言除外）。

在本文中，我们将接触一种显式控制程序执行过程的方法。
它不使用栈，而使用语言本身的特性。
它不但能完成栈的功能，而且允许我们灵活地引入新的程序结构，比如异常处理机制。

<!--more-->

## 尾调用等价于跳转 ##

在以栈实现函数调用的语言中，并不是所有的函数调用都一定要增加栈的深度。

**尾调用并不增加栈深度，因为尾调用等价于跳转。**

举一个 C 语言程序的例子（假设该程序使用寄存器传递参数）：

```c
int min2(int a, int b) {
  return a < b ? a : b;
}

int min3(int a, int b, int c) {
  int d;
  d = min2(a, b);
  return min2(d, c);
}
```

`min3` 调用了两次 `min2` ，第二次调用之后原函数就返回，因此第二次调用是尾调用。

从程序编译期优化的角度考虑，我们可以优化第二次调用，让它直接重用当前的帧（frame，即函数在栈上使用的空间），
在寄存器中存储了适当的参数后直接跳转到 `min2` 函数开始处。当 `min2` 返回时，实际上返回到了调用 `min3` 的位置。

因此，对于支持尾调用优化的语言，我们可以放心地使用尾调用，尤其是尾递归，而不必担心栈深度增长。

**在优化尾调用的语言中，尾递归等价于循环。**

需要注意的是，下面这个函数 return 语句的调用并不是尾调用，因为它在调用后还做了加法运算：

```c
int min_plus_one(int a, int b) {
  return min2(a, b) + 1;
}
```

如果我们能够将程序中的所有函数调用都改写为尾调用，我们的程序的运行过程就不再需要栈了。

在接下来的部分，我们将以 Scheme 为例，了解如何将程序改写为只含有尾调用的形式。

## 哪些调用是尾调用 ##

对于一个 Scheme 程序，我们需要首先了解哪些位置的调用是尾调用。

通常来讲，**如果表达式的某个位置的值就是该表达式的值，那么这个位置就是该表达式的尾位置，该位置的调用就是尾调用。**

我们将一些基本 Scheme 表达式中的尾位置用 `T` 标示出来，其他位置用 `E`（子表达式） 或 `S`（符号）标示，`...` 代表重复零个或多个它之前的位置：

```scheme
(lambda (S ...) T)
(let ((S E) ...) T)
(if E T T)
(begin E ... T)
(E E ...)             ; 函数调用
```

**尾位置具有传递性**，也就是处于尾位置的子表达式的尾位置也是外层表达式的尾位置。比如以下 Scheme 表达式：

```scheme
(let ((S E) ...) (if (begin E ...) T T))
```

这个表达式中 if 的两个分支也是整个 let 表达式的尾位置，但是 begin 的所有子表达式都不是尾位置。

## Continuation ##

在一个表达式中，对于某个子表达式，它求值完成后之后需要求值的部分被称作它的 **continuation** 。

以一个将四个数相加的程序为例：

```scheme
(+ (+ 1 (+ 2 3)) 4)
```

在这段程序中，`(+ 2 3)` 的 continuation 是 `(+ (+ 1 R) 4)`（我们将用 R 表示子表达式所在位置）。

我们可以将这个 continuation 理解为：
`(+ 2 3)` 求值完成后，用它的结果去计算 `(+ (+ 1 R) 4)`，其中 R 替换为该函数调用的结果。

一个更复杂的 continuation 参见下面的例子：

```scheme
(+ 4 (if (> 3 2) (- 2 1) 6))
```

在这个表达式中，`(> 3 2)` 的 continuation 是 `(+ 4 (if R (- 2 1) 6))`。

我们可以将 continuation 写成一个函数。在上面的例子中，我们可以将它写为：

```scheme
(lambda (v)
  (+ 4 (if v (- 2 1) 6)))
```

## 将所有的调用都写成尾调用 ##

首先，我们根据是否包含函数调用来区分两种表达式，即简单表达式（不包含函数调用，用 SE 表示）和复杂表达式（包含函数调用，用 CE 表示）。

简单表达式出现在任何位置都不会导致栈深度增加，因此，我们需要考虑如何处理复杂表达式。

## CPS 变换 ##
