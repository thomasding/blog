---
layout: post
title: Linux 共享对象的动态加载原理
tags: [操作系统, c++]
comments: true
---

各个操作系统都提供了将一个程序拆分成多个文件的方法。Windows 提供了动态链接库（dynamic link library），Linux 提供了共享对象（shared object），macOS 提供了动态库（dynamic library）。这些统称为**动态共享对象（dynamic shared object）****。

本文讲解了 Linux 中的共享对象在程序启动时的加载过程。

在阅读本文前，读者需要对符号表和重定位表有所了解。关于符号表和重定位表的讲解可以阅读[《图解 Linux 程序的链接原理》][1]。

<!--more-->

## 位置无关代码（PIC） ##

可执行程序在内存中的位置是在链接时就可以确定，然而共享对象在链接时不能确定它在内存中的位置。这要求共享对象内的指令不能够使用绝对地址来访问全局变量和函数。

如果共享对象在链接时指定好了它在内存中的位置，那么当一个程序依赖了两个共享对象而这两个共享对象在内存中的位置重叠时，就无法成功加载程序。因此，共享对象必须能够被加载到内存中的任意位置。

虽然共享对象在内存中的位置不确定，但是在加载时共享对象会被当作一个整体加载到内存之中，段与段之间的距离恒定不变。最重要的是，代码段与数据段之间的距离是恒定的。因此，在访问全局变量和函数时必须使用**相对寻址（relative addressing）**。

与 **绝对寻址（absolute addressing）** 不同，相对寻址根据要访问的内存单元到当前 **程序计数器（program counter）** 的相对距离来寻址。不管共享对象被加载到内存中的哪个位置，相对距离都不会改变。

这样的不依赖在内存中的位置的代码被称作 **位置无关代码（position independent code）** ，在编译和链接时可以通过传递 **-fpic** 参数来生成。

然而，相对寻址无法解决访问外部符号的问题，具体体现为：

1. 访问了其他共享对象中导出的变量；
2. 调用了其他共享对象中导出的函数。

这两种情况都是因为在程序加载前，我们无法知道其他共享对象在内存中的位置。

## Global Offset Table ##

我们可以通过加载时重定位代码段的方法解决依赖其他共享对象的符号的问题。然而在加载时重定位代码段有两个障碍：

1. 因为每一处引用外部符号的地方都需要重定位，所以重定位需要花费很多时间；
2. 因为需要修改代码段，所以当同一个共享对象被加载到不同的进程空间内时，无法共享代码段的内存页。

为了解决这两个问题，我们引入了 **global offset table（简称 GOT）**。

GOT 存放在数据段中的，节名为 **.got** 。它是一个数组，数组元素的长度就是该平台下地址的长度。在运行时，每一个数组元素都存放一个地址。

每一个需要访问的外部符号在 GOT 中都有一个对应的表项，存储该符号的内存地址。

在访问外部符号时，程序首先从 GOT 中读取该符号的内存地址，然后再访问该符号所在的内存单元。

因为 GOT 是共享对象数据段的一部分，所以可以使用相对寻址来访问 GOT 中的表项。

每个共享对象有一个属于它的 GOT，该 GOT 有一个关联的重定位表。在程序加载时，加载器根据重定位表将符号的内存地址填写到 GOT 中，完成重定位。

相比于直接重定位代码段的方法，GOT 的引入解决了一部分效率问题：

1. 不管一个外部符号在代码中被引用多少次，只需要修改一处 GOT 表项即可完成重定位；
2. GOT 在数据段中，所以代码段可以在多个进程间共享。

## Procedure Linkage Table ##

然而，GOT 的效率仍然不够高。

通常来说，一个共享对象引用的外部函数要比它引用的外部变量多很多。然而，大部分函数在正常的工作流中很有可能不会被调用到。因此，我们可以将外部函数的 **解析（resolve）** 推迟到它被调用的时候。

实现 **延迟解析（lazy resolution）** 需要借助于 **procedure linkage table（简称 PLT）**。

与 GOT 不同，PLT 是一组特殊的代码，它存放于共享对象的代码段之中，节名是 **.plt** 。PLT 的第一个表项有特殊的用途，其余每个表项对应一个外部函数。

一个 PLT 与一个 GOT 相关联，这个 GOT 的名字为 **.got.plt** 。GOT 的前三个表项用于特殊的用途，其他的每个表项都与一个 PLT 表项对应。

因此，一个共享对象通常包含两个 GOT ，名为 .got 的用于外部变量，名为 .got.plt 的用于外部函数。

PLT 表项中的代码一般可以描述为如下的伪代码（其中 func@PLT 代表外部函数 func 在 PLT 中的表项，func@GOTPLT 代表外部函数 func 在 GOT 中的表项）：

```text
func@PLT:
  jmp  *func@PLTGOT     # 跳转到 func@PLTGOT 所存储的内存地址
  push index_of_func    # 将代表该函数在 PLT 中的下标入栈
  jmp  PLT[0]           # 跳转到 PLT 的第一个表项处，以解析 func
```

在程序加载时，加载器将 GOT[0] 初始化为空，将 GOT[1] 初始化为该共享对象的唯一标识，将 GOT[2] 初始化为加载器中提供延迟解析功能的函数的地址，将其他 GOT 表项初始化为对应 PLT 表项中 `push index_of_func` 所在的内存地址。

当 PLT 中的函数被第一次调用时，`jmp *func@PLTGOT` 会跳转到 `push index_of_func` 指令，然后跳转到 PLT[0] 处。PLT[0] 跳转到加载器中用于延迟解析的函数，将 func@PLTGOT 修改为被调用函数的内存地址，并跳转到该函数的入口地址。

当该函数被第二次调用时，`jmp *func@PLTGOT` 就会直接跳转到该函数的入口地址。

PLT[0] 可以用如下伪代码描述：

```text
PLT[0]:
  push GOT[1]           # 将共享对象的唯一标识当作参数
  jmp  GOT[2]           # 调用加载器的延迟解析函数
  nop                   # 补齐到和其他 PLT 表项一样长
  nop
```

## 小结 ##

动态加载使用 GOT 和 PLT 完成外部符号的重定位。

1. GOT 用于存放外部变量的内存地址，在程序加载时完成解析；
2. PLT 用于延迟解析外部函数。
