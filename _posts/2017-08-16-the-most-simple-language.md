---
layout: post
title: 最小的编程语言
tags: [程序理论]
comments: true
---

从第一堂 C++ 课开始，我们就在培养这样的思维习惯：*先把 a 复制给 b，再把 b + c 赋值给 d，然后跳转到第二步，直到满足*……
这种**命令式**的思维对我们的影响是如此深刻，以至于我们倾向于用这种思维方式去理解编程世界中的一切。

马洛斯说：“当你手里唯一的工具是锤子时，所有的问题看起来就像是钉子。”

当我们手握着命令式思维的锤子时，我们发现，这个日新月异的编程世界是如此令人迷惑。
**函数式编程**、**回调函数**、**协程**就像是两头尖的钉子一般，令我们无所适从。

为了揭开这些概念背后的统一本质，我们将从最小的编程语言入手，逐步丰富它的内核。
在这个过程中，曾经难以理解的概念就像是树干上萌生的枝叶一样，将会自然而然地发展出来。

<!--more-->

## 从零起步的最小语言 ##

我们的最小语言由三种 term 组成：

1. **变量**：`x`, `y` 等。
2. **函数**：由一个变量 `v` 和一个 term `t` 以 `λv.t` 的形式组成，比如 `λx.x` 就是一个接受任何参数并返回它自己的函数。
3. **调用**：由两个 term 以 `t1 t2` 的形式组成，比如 `(λx.x) y`。

为了减少不必要的括号，我们规定函数可以延伸到最长的位置，调用按照从左到右的顺序结合。
因此，`λa. λb. b a c` 等价于 `λa. (λb. ((b a) c))` 。

我们就可以根据以上规则来组合出一些复杂的 term，比如：

```text
(λa. λb. a b) (λx.x) y
```

我们暂时并不需要明白上面这个 term 的含义是什么，只需要了解，**我们可以根据以上三个规则生成相当复杂的程序**就可以。
很快我们就可以发现，仅仅需要以上三个规则和一条运算规则，就可以完成 C++/Java/Python 这些复杂语言所具备的所有功能。

到目前为止，我们只定义了这个最小语言的语法，还没有说明如何执行它。
因此，我们接下来定义这个语言的运算规则。幸运的是，这个语言的运算规则只有一条：

- 对于形如 `(λx.t1) t2` 的 term，我们将 `t1` 中出现的所有 `x` 都替换为 t2。这个替换操作可以写成 `[x → t2]t1` 。

上面的例子就可以进行如下运算：

```text
    (λa. λb. a b) (λx.x) y
⇒   (λb. (λx.x) b) y    用 λx.x 替换 a
⇒   (λb. b) y           用 b 替换 x
⇒   y                   用 y 替换 b
```

## 运算顺序和 Lazy Evaluation ##

细心的读者会发现，对于上面的例子，我们还有另外一种运算顺序，也就是在第二步先用 y 替换 b，如下所示：

```text
    (λa. λb. a b) (λx.x) y
⇒   (λb. (λx.x) b) y    用 λx.x 替换 a
⇒   (λx.x) y            用 y 替换 b
⇒   y                   用 y 替换 x
```

因为替换可以发生在 term 中的任何位置，所以，运算顺序是不唯一的。 为了减少替换的随意性，我们需要添加新的运算规则。

在添加运算规则前，我们要区分两种 term，一种是可以进行替换的，另一种是不可进行替换的。我们将不可替换的 term 称为值（value）。

首先，我们规定，**替换只能发生在最外层的函数上**。在这个规则下，一个变量或者一个函数都是不可以被继续替换的值。

对于我们的例子来说，只有第二种运算顺序是允许的。而第一种运算顺序先替换了内层的函数，因此是不允许的。

然而这仍然无法避免多种运算顺序，比如下面的例子：

```
(λa.λb.b) ((λx.x) y) z
```

这里 `λa.λb.b` 和 `λx.x` 都是最外层的函数，不存在嵌套关系，因此，先替换哪一个都是可以的。比如如下运算顺序：

```
    (λa.λb.b) ((λx.x) y) z
⇒   (λb.b) z         用 ((λx.x) y) 替换 a
⇒   z                用 z 替换 b
```

如果我们再规定，**对于形如 `t1 t2` 的调用，只有 t2 为值时才能替换**，那么这个 term 只有一种运算顺序，即：

```
    (λa.λb.b) ((λx.x) y) z
⇒   (λa.λb.b) y z    用 y 替换 x
⇒   (λb.b) z         用 y 替换 a
⇒   z                用 z 替换 b
```

在编程语言的世界里，第一种运算顺序称为 **call-by-name**，第二种为 **call-by-value** 。
几乎所有的主流编程语言都是 **call-by-value** 的。

但是我们不能忽视的是，就这个例子而言，**call-by-name** 的运算步骤更少，因为 `((λx.x) y)` 实际上没有被用到。
这被称为 lazy evaluation (延迟求值），即如果一个 term 不是运算继续下去所必须的，就不会被计算。

## 扩充一些新 term ##

一个只能定义函数和调用函数的语言看起来没有任何用途，因此，我们引入 if 表达式、布尔值、整数和基本的数学运算。

基于这些扩充的 term，我们可以写：

```text
if ((λa.λb. a * b) 2 3) > 0 then 1 else 2
```

这个程序的运算结果为 `1` 。

## 概念解释 ##

这个最小语言实际上是一个 **lambda calculus**。

将 `(λx.t1) t2` 变成 `[x → t2]t1` 的运算称为 **beta reduction** 。

一个形如 `(λx.t1) t2` 的 term 被称作 **reducible expression** ，简称 **redex** 。

Lambda calculus 上的运算就是不断地对 term 做 beta reduction 直到不可以做任何 beta reduction 为止。
