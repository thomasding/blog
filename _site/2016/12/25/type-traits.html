<!DOCTYPE html>
<html lang="en">

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Type Traits</title>
  <meta name="description" content="Only given a type T without any knowledge of how it is implemented, just as we encounter in template programming, what question can we ask about it? Here are...">

  <link rel="stylesheet" href="/assets/main.css">
  <link rel="canonical" href="http://tding.in/2016/12/25/type-traits.html">
  <link rel="alternate" type="application/rss+xml" title="tding.in" href="/feed.xml">
  
  
</head>


  <body>

    <header class="site-header" role="banner">

  <div class="wrapper">

    <a class="site-title" href="/">tding.in</a>

    <nav class="site-nav">
      <span class="menu-icon">
        <svg viewBox="0 0 18 15" width="18px" height="15px">
          <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
          <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
          <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
        </svg>
      </span>

      <div class="trigger">
        
        
          
        
          
        
          
        
          
        
          
          <a class="page-link" href="/archive/">Archive</a>
          
        
          
          <a class="page-link" href="/tags/">Tags</a>
          
        
      </div>
    </nav>

  </div>

</header>


    <main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">Type Traits</h1>
    <div class="post-meta">
      <time datetime="2016-12-25T00:00:00+08:00" itemprop="datePublished">Dec 25, 2016</time>
      <ul class="post-tags post-meta">
        
        <li>
          <a href="/tags/#c++" class="post-tag">c++</a>
        </li>
        
        <li>
          <a href="/tags/#metaprogramming" class="post-tag">metaprogramming</a>
        </li>
        
      </ul>
    </div>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p>Only given a type <strong>T</strong> without any knowledge of how it is implemented, just as
we encounter in template programming, what question can we ask about it? Here
are some questions that you may ask:</p>

<ol>
  <li>Is it an integral type/array/class/function/enum/union?</li>
  <li>Is it a lvalue/rvalue reference or non-reference?</li>
  <li>Is it const/volatile qualified?</li>
  <li>If it is a reference, what type is the non-reference part?</li>
  <li>If it is a pointer, what type is the object it points to?</li>
  <li>Is it the same type as type <strong>U</strong>?</li>
  <li>Is it a copy/move constructible/assignable?</li>
</ol>

<p>STL provides a collection of utility templates, called <strong>type traits</strong>, to
answer these questions about what feature a specific type <strong>T</strong> has. They are
defined in the header file <strong>&lt;type_traits&gt;</strong>.</p>

<!--more-->

<p>After reading the
post <a href="#">SFINAE: Conditionally Instantiating Function Templates</a>, you may have
already understood the skills about providing different implementations based on
the types of template parameters. However, the prerequisites of using
SFINAE are to determine the features that the given types provide. Before you
write two function templates that serve for pointers and non-pointers,
respectively, for example, it is required to distinguish a pointer type from a
non-pointer one.</p>

<p>Therefore, in order to master SFINAE skills, it is a necessity to be familiar
with type traits, from what they are used for to how they work. Finally, you
will be proficient at defining your own type traits.</p>

<h2 id="an-overview-of-type-traits">An overview of type traits</h2>

<p>Type traits can be grouped in two forms, one to determine whether a given type
<strong>T</strong> has a feature or not, which are usually called <strong>is_xxx</strong>, for example:</p>

<ol>
  <li>types: <strong>is_void</strong>, <strong>is_null_pointer</strong>, <strong>is_integral</strong>, <strong>is_array</strong>,
…</li>
  <li>type properties: <strong>is_const</strong>, <strong>is_volatie</strong>, <strong>is_reference</strong>,
<strong>is_abstract</strong>, …</li>
  <li>type relations: <strong>is_same</strong>, <strong>is_base_of</strong>, <strong>is_convertible</strong>, …</li>
  <li>supported operations: <strong>is_default_constructible</strong>,
<strong>is_move_assignable</strong>, …</li>
  <li>and etc.</li>
</ol>

<p>These type traits have a static constant data member <strong>value</strong>, which equals to
<strong>true</strong> if the type has the specified feature. For example:</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="n">std</span><span class="o">::</span><span class="n">is_array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span><span class="o">&gt;::</span><span class="n">value</span> <span class="o">==</span> <span class="nb">true</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">is_const</span><span class="o">&lt;</span><span class="k">const</span> <span class="kt">int</span><span class="o">&gt;::</span><span class="n">value</span> <span class="o">==</span> <span class="nb">true</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">is_rvalue_reference</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&amp;&gt;::</span><span class="n">value</span> <span class="o">==</span> <span class="nb">false</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">is_same</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="o">&gt;::</span><span class="n">value</span> <span class="o">==</span> <span class="nb">false</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">TrivialType</span> <span class="p">{</span> <span class="kt">int</span> <span class="n">a</span><span class="p">;</span> <span class="p">};</span>
<span class="n">std</span><span class="o">::</span><span class="n">is_default_constructible</span><span class="o">&lt;</span><span class="n">TrivialType</span><span class="o">&gt;::</span><span class="n">value</span> <span class="o">==</span> <span class="nb">true</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">ComplicatedType</span> <span class="p">{</span>
  <span class="n">ComplicatedType</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">)</span> <span class="o">:</span> <span class="n">val</span><span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span> <span class="p">{}</span>
  <span class="n">ComplicatedType</span><span class="p">(</span><span class="k">const</span> <span class="n">ComplicatedType</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
  <span class="n">ComplicatedType</span><span class="p">(</span><span class="n">ComplicatedType</span><span class="o">&amp;&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
  <span class="n">ComplicatedType</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">ComplicatedType</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
  <span class="n">ComplicatedType</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">ComplicatedType</span><span class="o">&amp;&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
  <span class="o">~</span><span class="n">ComplicatedType</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
  
  <span class="kt">int</span> <span class="n">val</span><span class="p">;</span>
<span class="p">};</span>
<span class="n">std</span><span class="o">::</span><span class="n">is_default_constructible</span><span class="o">&lt;</span><span class="n">ComplicatedType</span><span class="o">&gt;::</span><span class="n">value</span> <span class="o">==</span> <span class="nb">false</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">is_copy_constructible</span><span class="o">&lt;</span><span class="n">ComplicatedType</span><span class="o">&gt;::</span><span class="n">value</span> <span class="o">==</span> <span class="nb">false</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">is_move_constructible</span><span class="o">&lt;</span><span class="n">ComplicatedType</span><span class="o">&gt;::</span><span class="n">value</span> <span class="o">==</span> <span class="nb">true</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">is_destructible</span><span class="o">&lt;</span><span class="n">ComplicatedType</span><span class="o">&gt;::</span><span class="n">value</span> <span class="o">==</span> <span class="nb">true</span><span class="p">;</span>
</code></pre>
</div>

<p>The other form of type traits modifies the given type and returns another
derived type, for example:</p>

<ol>
  <li>const/volatile modifiers: <strong>add_const</strong>, <strong>remove_const</strong>, <strong>remove_volatile</strong>, …</li>
  <li>reference modifiers: <strong>remove_reference</strong>, <strong>add_lvalue_reference</strong>, …</li>
  <li>pointer modifiers: <strong>add_pointer</strong>, <strong>remove_pointer</strong></li>
  <li>sign modifiers: <strong>make_signed</strong>, <strong>make_unsigned</strong>,</li>
  <li>array modifiers: <strong>remove_extent</strong>, <strong>remove_all_extents</strong></li>
  <li>and etc.</li>
</ol>

<p>These type traits have a type member <strong>type</strong>, which is the modified type from
the given types. Like:</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">add_const</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">type</span> <span class="n">a</span><span class="p">;</span>                 <span class="c1">// const int
</span><span class="k">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">remove_reference</span><span class="o">&lt;</span><span class="k">const</span> <span class="kt">int</span><span class="o">&amp;&gt;::</span><span class="n">type</span> <span class="n">b</span><span class="p">;</span>   <span class="c1">// const int
</span><span class="k">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">remove_extent</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">[]</span><span class="o">&gt;::</span><span class="n">type</span> <span class="n">c</span><span class="p">;</span>           <span class="c1">// int
</span><span class="k">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">remove_extent</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">[</span><span class="mi">10</span><span class="p">][</span><span class="mi">20</span><span class="p">]</span><span class="o">&gt;::</span><span class="n">type</span> <span class="n">d</span><span class="p">;</span>     <span class="c1">// int[20]
</span><span class="k">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">remove_all_extents</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">[</span><span class="mi">10</span><span class="p">][</span><span class="mi">20</span><span class="p">]</span><span class="o">&gt;::</span><span class="n">type</span> <span class="n">e</span><span class="p">;</span><span class="c1">// int
</span></code></pre>
</div>

<p>Apart from the mentioned ones, there are some other utilities for type
manipulations, for example:</p>

<ol>
  <li>the equivalent if-statement for types: <strong>conditional</strong></li>
  <li>SFINAE tool: <strong>enable_if</strong></li>
  <li>type transformations happening in function arguments: <strong>decay</strong></li>
  <li>return type of a function: <strong>result_of</strong></li>
  <li>and etc.</li>
</ol>

<p>Just like those for type modifications, these utilities define a type member
<strong>type</strong>, which is the result of the specified operations.</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">conditional</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">is_const</span><span class="o">&lt;</span><span class="k">const</span> <span class="kt">int</span><span class="o">&gt;</span><span class="p">,</span>
                          <span class="kt">float</span><span class="p">,</span>
                          <span class="kt">double</span><span class="o">&gt;</span> <span class="n">a</span><span class="p">;</span>                <span class="c1">// float
</span><span class="k">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">decay</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">[</span><span class="mi">10</span><span class="p">][</span><span class="mi">20</span><span class="p">]</span><span class="o">&gt;::</span><span class="n">type</span> <span class="n">b</span><span class="p">;</span>           <span class="c1">// int(*)[20]
</span>
<span class="c1">// std::enable_if has type member `type` only if the boolean value passed to 
// it is true. In this example, if T is not a reference, std::enable_if will
// have no `type` member, causing type substitution failure.
</span><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> 
          <span class="k">typename</span> <span class="o">=</span> <span class="k">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">enable_if</span><span class="o">&lt;</span>
                       <span class="n">std</span><span class="o">::</span><span class="n">is_reference</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">value</span>
                     <span class="o">&gt;::</span><span class="n">type</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">foo</span><span class="p">(</span><span class="n">T</span> <span class="n">v</span><span class="p">)</span> <span class="p">{}</span>
</code></pre>
</div>

<p>For those who are not familiar with template programming, type traits look like
mysterious magic. After all, how can you judge whether or not a type is a class
or a primitive type? How can you remove the constness of a type? Consequently,
it turns out that the best way to learn type traits is to find out how they are
implemented, in which way not only are we accustomed to the thinking of template
programming, but skilled to extend the power of type traits.</p>

<h2 id="defining-type-traits-1-the-direct-way">Defining type traits 1: the direct way</h2>

<p>Some type traits like <strong>add_const</strong>, <strong>add_lvalue_reference</strong> and
<strong>add_volatile</strong> are very straightforward. Hence, we can take them as a warm-up
to the real fantastic part.</p>

<p>Although STL uses <strong>typedef</strong> to define type members, we apply the <strong>using</strong>
statement in all our examples, since they are more readable than the convoluted
<strong>typedef</strong> and more powerful as well.</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span> <span class="k">struct</span> <span class="n">add_const</span> <span class="p">{</span> <span class="k">using</span> <span class="n">type</span> <span class="o">=</span> <span class="k">const</span> <span class="n">T</span><span class="p">;</span> <span class="p">};</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span> <span class="k">struct</span> <span class="n">add_lvalue_reference</span> <span class="p">{</span> <span class="k">using</span> <span class="n">type</span> <span class="o">=</span> <span class="n">T</span><span class="o">&amp;</span><span class="p">;</span> <span class="p">};</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span> <span class="k">struct</span> <span class="n">add_rvalue_reference</span> <span class="p">{</span> <span class="k">using</span> <span class="n">type</span> <span class="o">=</span> <span class="n">T</span><span class="o">&amp;&amp;</span><span class="p">;</span> <span class="p">};</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span> <span class="k">struct</span> <span class="n">add_pointer</span> <span class="p">{</span> <span class="k">using</span> <span class="n">type</span> <span class="o">=</span> <span class="n">T</span><span class="o">*</span><span class="p">;</span> <span class="p">};</span>
</code></pre>
</div>

<h2 id="defining-type-traits-2-template-specialization">Defining type traits 2: template specialization</h2>

<p>More non-trivial type traits like <strong>remove_reference</strong> cannot be directly
defined. Hence, we need to pursue more powerful tools, like template
specialization.</p>

<h3 id="background-knowledge-of-template-specialization">Background knowledge of template specialization</h3>

<p>Given the most basic implementation of a template, you can define a different
implementation for a specific type, which is called <strong>full specialization</strong>. The
code above defines a basic template and two implementations that are specialized
for int and float, respectively.</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span> <span class="k">struct</span> <span class="n">A</span> <span class="p">{</span> <span class="n">T</span> <span class="n">v</span><span class="p">;</span> <span class="p">};</span>
<span class="k">template</span> <span class="o">&lt;&gt;</span> <span class="k">struct</span> <span class="n">A</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="p">{</span> <span class="kt">int</span> <span class="n">v</span><span class="p">;</span> <span class="kt">bool</span> <span class="n">is_zero</span><span class="p">;</span> <span class="p">};</span>
<span class="k">template</span> <span class="o">&lt;&gt;</span> <span class="k">struct</span> <span class="n">A</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span> <span class="p">{</span> <span class="kt">double</span> <span class="n">v</span><span class="p">;</span> <span class="p">};</span>
</code></pre>
</div>

<p>To specialize a template for a concrete type <strong>A</strong>, you need to preserve the
template declaration with <code class="highlighter-rouge">template &lt;&gt;</code> and put the actual type in the brackets
after the template name. The same rule applies for the cases of more than one
template parameters. For example:</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="n">templ</span>
<span class="n">ate</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">U</span><span class="o">&gt;</span> <span class="k">struct</span> <span class="n">B</span> <span class="p">{</span> <span class="n">T</span> <span class="n">a</span><span class="p">;</span> <span class="n">U</span> <span class="n">b</span><span class="p">;</span> <span class="p">};</span>
<span class="k">template</span> <span class="o">&lt;&gt;</span> <span class="k">struct</span> <span class="n">B</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">float</span><span class="o">&gt;</span> <span class="p">{</span> <span class="kt">int</span> <span class="n">a</span><span class="p">;</span> <span class="kt">float</span> <span class="n">b</span><span class="p">;</span> <span class="kt">char</span> <span class="n">c</span><span class="p">;</span> <span class="p">};</span>
<span class="k">template</span> <span class="o">&lt;&gt;</span> <span class="k">struct</span> <span class="n">B</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="p">{};</span>
</code></pre>
</div>

<p>The specialized version of a template can be completed different from the basic
one. Hence, it is the author’s responsibility to guarantee that the
specialization is reasonable. In the following examples, we will omit the actual
body of a template definition if we don’t care about it.</p>

<p>Besides a concrete type, you can also specialize a template for a smaller case,
for example, providing another implementation for all pointer types. This is
called <strong>partial specialization</strong>.</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span> <span class="k">struct</span> <span class="n">B</span> <span class="p">{};</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span> <span class="k">struct</span> <span class="n">B</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&amp;&gt;</span> <span class="p">{};</span>  <span class="c1">// Specialized for lvalue references.
</span><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span> <span class="k">struct</span> <span class="n">B</span><span class="o">&lt;</span><span class="n">T</span><span class="o">*&gt;</span> <span class="p">{};</span>  <span class="c1">// Specialized for pointers.
</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">U</span><span class="o">&gt;</span> <span class="k">struct</span> <span class="n">C</span> <span class="p">{};</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span> <span class="k">struct</span> <span class="n">C</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="p">{};</span> <span class="c1">// Specialized for the same types.
</span><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span> <span class="k">struct</span> <span class="n">C</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">T</span><span class="o">&amp;&gt;</span> <span class="p">{};</span> <span class="c1">// Specialized for C&lt;A, A&amp;&gt; cases.
</span></code></pre>
</div>

<p>By applying partial specialization, we can define more sophisticated type
traits. But before that, we need to know how to represent true and false in
template programming, especially in the world of type traits.</p>

<h3 id="background-knowledge-of-stdtruetype-and-stdfalsetype">Background knowledge of std::true_type and std::false_type</h3>

<p>In type traits, instead of directly using boolean literals like <strong>true</strong> and
<strong>false</strong>, we apply two special types: <strong>std::true_type</strong> and
<strong>std::false_type</strong>. They both contain a static constant member named
<strong>value</strong>, which is <strong>true</strong> for <strong>std::true_type</strong> and <strong>false</strong> for
<strong>std::false_type</strong>. The type of <strong>value</strong> is <strong>bool</strong>. Furthermore, a
<strong>std::true_type</strong> object is able to be implicitly converted to a boolean value
whose value is <strong>true</strong>, and so is <strong>std::false_type</strong>.</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="n">std</span><span class="o">::</span><span class="n">true_type</span><span class="o">::</span><span class="n">value</span> <span class="o">==</span> <span class="nb">true</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">false_type</span><span class="o">::</span><span class="n">value</span> <span class="o">==</span> <span class="nb">false</span><span class="p">;</span>
</code></pre>
</div>

<p>There are many advantages that two different types have over boolean
literals. The first one is that deriving from types is shorter than defining
static constants:</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="c1">// Use true_type.
</span><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span> <span class="k">struct</span> <span class="n">my_trait</span> <span class="o">:</span> <span class="n">true_type</span> <span class="p">{};</span>
<span class="c1">// Use boolean literal.
</span><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span> <span class="k">struct</span> <span class="n">my_trait</span> <span class="p">{</span> <span class="k">static</span> <span class="k">const</span> <span class="kt">bool</span> <span class="n">value</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span> <span class="p">};</span>
</code></pre>
</div>

<p>However, only taking the length of code into account does not answer the
question completely, because it seems where <strong>std::true_type</strong> and
<strong>std::false_type</strong> are applied, <strong>true</strong> and <strong>false</strong> can do as well, only
more redundant.</p>

<p>A deeper reason that <strong>std::true_type</strong> and <strong>std::false_type</strong> are required
lies in the excessive use of SFINAE in template programming, especially type
traits. It is common to provide two complementary function templates with the
same signature (argument types), one applied for some types and the other for
the rest. Because we never actually call the function, the only way to
distinguish one from the other is by the return type. We don’t call the
function, so we won’t know the return value. Since C++11, <strong>constexpr</strong> has been
a way to define functions that return compile-time constants. However, type
traits exist prior to C++11 before <strong>constexpr</strong> is added to the language.</p>

<p>In the example below, we can determine the type passed to function <strong>foo</strong> by
examining the return type of <strong>foo</strong>.</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span> <span class="n">false_type</span> <span class="n">is_int</span><span class="p">(</span><span class="n">T</span><span class="p">)</span> <span class="p">{}</span>
<span class="k">template</span> <span class="o">&lt;&gt;</span> <span class="n">true_type</span> <span class="n">is_int</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="p">{}</span>
</code></pre>
</div>

<p>The functions above look quite like a type trait already.</p>

<p>One more step, <strong>std::true_type</strong> and <strong>std::false_type</strong> are actually template
specializations of <strong>std::integral_constant</strong>, whose first parameter is an
integral type and second parameter the value:</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">using</span> <span class="n">true_type</span> <span class="o">=</span> <span class="n">integral_constant</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">,</span> <span class="nb">true</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">using</span> <span class="n">false_type</span> <span class="o">=</span> <span class="n">integral_constant</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">,</span> <span class="nb">false</span><span class="o">&gt;</span><span class="p">;</span>
</code></pre>
</div>

<h3 id="type-traits-using-template-specialization">type traits using template specialization</h3>

<p>Using partial specialization, we can define many type modifiers to remove
const/volatile qualifiers, references and pointers:</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="c1">// Remove the const/volatile qualifiers of a type.
</span><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span> <span class="k">struct</span> <span class="n">remove_cv</span> <span class="p">{</span> <span class="k">using</span> <span class="n">type</span> <span class="o">=</span> <span class="n">T</span><span class="p">;</span> <span class="p">};</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span> <span class="k">struct</span> <span class="n">remove_cv</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span> <span class="k">using</span> <span class="n">type</span> <span class="o">=</span> <span class="n">T</span><span class="p">;</span> <span class="p">};</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span> <span class="k">struct</span> <span class="n">remove_cv</span><span class="o">&lt;</span><span class="k">volatile</span> <span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span> <span class="k">using</span> <span class="n">type</span> <span class="o">=</span> <span class="n">T</span><span class="p">;</span> <span class="p">};</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span> <span class="k">struct</span> <span class="n">remove_cv</span><span class="o">&lt;</span><span class="k">const</span> <span class="k">volatile</span> <span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span> <span class="k">using</span> <span class="n">type</span> <span class="o">=</span> <span class="n">T</span><span class="p">;</span> <span class="p">};</span>

<span class="c1">// Remove the reference part of a type.
</span><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span> <span class="k">struct</span> <span class="n">remove_reference</span> <span class="p">{</span> <span class="k">using</span> <span class="n">type</span> <span class="o">=</span> <span class="n">T</span><span class="p">;</span> <span class="p">};</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span> <span class="k">struct</span> <span class="n">remove_reference</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&amp;&gt;</span> <span class="p">{</span> <span class="k">using</span> <span class="n">type</span> <span class="o">=</span> <span class="n">T</span><span class="p">;</span> <span class="p">};</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span> <span class="k">struct</span> <span class="n">remove_reference</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&amp;&amp;&gt;</span> <span class="p">{</span> <span class="k">using</span> <span class="n">type</span> <span class="o">=</span> <span class="n">T</span><span class="p">;</span> <span class="p">};</span>

<span class="c1">// And so on.
</span></code></pre>
</div>

<p>Another basic type trait that is intensively used by other type traits is
<strong>is_same</strong>, which compares whether the two given types are identical:</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">U</span><span class="o">&gt;</span> <span class="k">struct</span> <span class="n">is_same</span> <span class="o">:</span> <span class="n">false_type</span> <span class="p">{};</span>
<span class="n">tmeplate</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span> <span class="k">struct</span> <span class="n">is_same</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="o">:</span> <span class="n">true_type</span> <span class="p">{};</span>
</code></pre>
</div>

<p>Using the type traits above, we can define a type trait to check whether the
given type is a floating-point number:</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="c1">// The C++11 style
</span><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span> <span class="n">is_floating_point</span> 
    <span class="o">:</span> <span class="n">integral_type</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">,</span> <span class="n">is_same</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="k">typename</span> <span class="n">remove_cv</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">type</span><span class="o">&gt;::</span><span class="n">value</span> <span class="o">||</span>
                          <span class="n">is_same</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="k">typename</span> <span class="n">remove_cv</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">type</span><span class="o">&gt;::</span><span class="n">value</span> <span class="o">||</span>
                          <span class="n">is_same</span><span class="o">&lt;</span><span class="kt">long</span> <span class="kt">double</span><span class="p">,</span> <span class="k">typename</span> <span class="n">remove_cv</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">type</span><span class="o">&gt;::</span><span class="n">value</span><span class="o">&gt;</span> <span class="p">{};</span>
</code></pre>
</div>

<h2 id="defining-type-traits-3-sfinae">Defining type traits 3: SFINAE</h2>

<h2 id="episode-simplifying-the-type-traits-returning-types">Episode: simplifying the type traits returning types</h2>

<p>The type declaration when using a type trait can be very long, like the
following code that adds the const qualifier to a given type:</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="n">foo</span><span class="p">(</span><span class="k">typename</span> <span class="n">add_const</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">type</span> <span class="n">myvalue</span><span class="p">)</span> <span class="p">{}</span>
</code></pre>
</div>

<p>By type aliasing, we can obviously shrink the length of the type description:</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span> <span class="k">using</span> <span class="n">add_const_t</span> <span class="o">=</span> <span class="k">typename</span> <span class="n">add_const</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">type</span><span class="p">;</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="n">foo</span><span class="p">(</span><span class="n">add_const_t</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">myvalue</span><span class="p">)</span> <span class="p">{}</span>
</code></pre>
</div>

<p>Sadly, these helpful type aliasing definitions were not introduced to C++ until
C++14. Hence, you would have to use the old long redundant type descriptions
prior to C++14 should you not define them manually. In the post, we assume these
type aliasing, which are uniformly in the form of <code class="highlighter-rouge">template &lt;class T&gt; using
foo_t = typename foo&lt;T&gt;::type</code> .</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="c1">// Since C++14
</span><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span> <span class="n">add_lvalue_reference_t</span> 
    <span class="o">=</span> <span class="k">typename</span> <span class="n">add_lvalue_reference</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">type</span><span class="p">;</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span> <span class="n">add_rvalue_reference_t</span>
    <span class="o">=</span> <span class="k">typename</span> <span class="n">add_rvalue_reference</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">type</span><span class="p">;</span>
</code></pre>
</div>

<p>In the following sections, sometimes we omit these type aliasing definitions for
brevity. But we’ll use them as if they have been defined as long as not causing
confusion.</p>

<p>Then, we add type aliasing definitions to the type traits above:</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span> <span class="k">using</span> <span class="n">remove_cv_t</span> <span class="o">=</span> <span class="k">typename</span> <span class="n">remove_cv</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">type</span><span class="p">;</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span> <span class="k">using</span> <span class="n">remove_reference_t</span> 
    <span class="o">=</span> <span class="k">typename</span> <span class="n">remove_reference</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">type</span><span class="p">;</span> 
</code></pre>
</div>

<p>Similar to type aliasing, STL provides helpers to simplify the use of these
constant expressions by variable templates. Unfortunately, the syntax of
variable templates was added to C++14, and the helpers based on variable
templates for type traits weren’t available until C++17. Nevertheless, since
they greatly improve the convenience of template meta-programming, we will be
using these variable templates through the post.</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="c1">// Since C++17
</span><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">U</span><span class="o">&gt;</span> <span class="k">constexpr</span> <span class="kt">bool</span> <span class="n">is_same_v</span> <span class="o">=</span> <span class="n">is_same</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">U</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">;</span>
</code></pre>
</div>

<p>// The C++14 &amp; C++17 style
template <class T=""> is_floating_point
    : integral_type&lt;bool, is_same_v&lt;float, remove_cv_t<T>&gt; ||
                          is_same_v&lt;double, remove_cv_t<T>&gt; ||
                          is_same_v&lt;long double, remove_cv_t<T>&gt;&gt; {};</T></T></T></class></p>


  </div>

  
    

  
</article>




      </div>
    </main>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">tding.in <small><a href="/feed.xml">via RSS</a></small></h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li>
          
            Thomas Ding
          
          </li>
          
          <li><a href="mailto:thomasbyding@gmail.com">thomasbyding@gmail.com</a></li>
          
          
          <li>
            <a href="https://github.com/thomasding"><span class="icon icon--github"><svg viewBox="0 0 16 16" width="16px" height="16px"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span><span class="username">thomasding</span></a>

          </li>
          
          
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <p>Covering instruction-level optimization, C++ features, best practices and so many other interesting topics.
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
