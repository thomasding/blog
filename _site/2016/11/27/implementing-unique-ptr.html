<!DOCTYPE html>
<html lang="en">

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Implementing unique_ptr</title>
  <meta name="description" content="unique_ptr is one of the best features of C++11. It is not only a necessity at hand, but an exemplar of C++11 style programming. Unlike its cousin shared_ptr...">

  <link rel="stylesheet" href="/assets/main.css">
  <link rel="canonical" href="http://tding.in/2016/11/27/implementing-unique-ptr.html">
  <link rel="alternate" type="application/rss+xml" title="tding.in" href="/feed.xml">
  
  
</head>


  <body>

    <header class="site-header" role="banner">

  <div class="wrapper">

    <a class="site-title" href="/">tding.in</a>

    <nav class="site-nav">
      <span class="menu-icon">
        <svg viewBox="0 0 18 15" width="18px" height="15px">
          <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
          <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
          <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
        </svg>
      </span>

      <div class="trigger">
        
        
          
        
          
        
          
        
          
        
          
          <a class="page-link" href="/archive/">Archive</a>
          
        
          
          <a class="page-link" href="/tags/">Tags</a>
          
        
      </div>
    </nav>

  </div>

</header>


    <main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">Implementing unique_ptr</h1>
    <div class="post-meta">
      <time datetime="2016-11-27T00:00:00+08:00" itemprop="datePublished">Nov 27, 2016</time>
      <ul class="post-tags post-meta">
        
        <li>
          <a href="/tags/#c++" class="post-tag">c++</a>
        </li>
        
      </ul>
    </div>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p><strong>unique_ptr</strong> is one of the best features of C++11. It is not only a necessity
at hand, but an exemplar of C++11 style programming. Unlike its cousin
<strong>shared_ptr</strong> and <strong>weak_ptr</strong>, <strong>unique_ptr</strong> is simple and free from
details about reference counting. Therefore, we are going to implement our own
<strong>unique_ptr</strong> in this post and show how to program with C++11.</p>

<!--more-->

<h2 id="basic-step">Basic step</h2>

<p>A <strong>unique_ptr</strong> holds the pointer to an object, which can be transferred
between <strong>unique_ptrs</strong>. When a <strong>unique_ptr</strong> is destroyed as it holds an
object, the object is freed by the default <strong>delete</strong> operator or a custom
deleter function. In the basic step, we assume that an object can only be
deleted by the <strong>delete</strong> operator. We will support custom deleter functions in
the the following sections.</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="cp">#include &lt;utility&gt;
</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">unique_ptr</span> <span class="p">{</span>
 <span class="k">public</span><span class="o">:</span>
  <span class="c1">// Constructors that makes an empty unique_ptr.
</span>  <span class="k">constexpr</span> <span class="n">unique_ptr</span><span class="p">()</span> <span class="k">noexcept</span> <span class="o">:</span> <span class="n">ptr_</span><span class="p">(</span><span class="nb">nullptr</span><span class="p">)</span> <span class="p">{}</span>
  <span class="k">constexpr</span> <span class="n">unique_ptr</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">nullptr_t</span><span class="p">)</span> <span class="k">noexcept</span> <span class="o">:</span> <span class="n">ptr_</span><span class="p">(</span><span class="nb">nullptr</span><span class="p">)</span> <span class="p">{}</span>

  <span class="c1">// Constructor that makes a unique_ptr that holds the given object.
</span>  <span class="k">explicit</span> <span class="n">unique_ptr</span><span class="p">(</span><span class="n">T</span><span class="o">*</span> <span class="n">p</span><span class="p">)</span> <span class="k">noexcept</span> <span class="o">:</span> <span class="n">ptr_</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="p">{}</span>

  <span class="c1">// Move constructor. Transfer the object from u to this object.
</span>  <span class="n">unique_ptr</span><span class="p">(</span><span class="n">unique_ptr</span><span class="o">&amp;&amp;</span> <span class="n">u</span><span class="p">)</span> <span class="k">noexcept</span> <span class="o">:</span> <span class="n">ptr_</span><span class="p">(</span><span class="n">u</span><span class="p">.</span><span class="n">ptr_</span><span class="p">)</span> <span class="p">{</span> <span class="n">u</span><span class="p">.</span><span class="n">ptr_</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span> <span class="p">}</span>

  <span class="c1">// Move assignment operator can be implemented by swapping.
</span>  <span class="n">unique_ptr</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">unique_ptr</span><span class="o">&amp;&amp;</span> <span class="n">u</span><span class="p">)</span> <span class="k">noexcept</span> <span class="p">{</span>
    <span class="n">swap</span><span class="p">(</span><span class="n">u</span><span class="p">);</span>
    <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// Swap with another unique_ptr object.
</span>  <span class="kt">void</span> <span class="n">swap</span><span class="p">(</span><span class="n">unique_ptr</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="k">noexcept</span> <span class="p">{</span>
    <span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">;</span>
    <span class="n">swap</span><span class="p">(</span><span class="n">ptr_</span><span class="p">,</span> <span class="n">other</span><span class="p">.</span><span class="n">ptr_</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="c1">// Explicitly delete the copy constructor and copy assignment operator.
</span>  <span class="n">unique_ptr</span><span class="p">(</span><span class="k">const</span> <span class="n">unique_ptr</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
  <span class="n">unique_ptr</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">unique_ptr</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>

  <span class="c1">// Destructor.
</span>  <span class="o">~</span><span class="n">unique_ptr</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// Delete the object if the unique_ptr is holding one.
</span>    <span class="k">if</span> <span class="p">(</span><span class="n">ptr_</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">delete</span> <span class="n">ptr_</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="c1">// Access the object.
</span>  <span class="n">T</span><span class="o">*</span> <span class="n">get</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span> <span class="p">{</span> <span class="k">return</span> <span class="n">ptr_</span><span class="p">;</span> <span class="p">}</span>

  <span class="c1">// Overloads dereferencing operators so that a unique_ptr resembles a raw
</span>  <span class="c1">// pointer, like *uptr and uptr-&gt;member.
</span>  <span class="n">T</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">*</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span> <span class="p">{</span> <span class="k">return</span> <span class="o">*</span><span class="n">ptr_</span><span class="p">;</span> <span class="p">}</span>
  <span class="n">T</span><span class="o">*</span> <span class="k">operator</span><span class="o">-&gt;</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span> <span class="p">{</span> <span class="k">return</span> <span class="n">ptr_</span><span class="p">;</span> <span class="p">}</span>
  
  <span class="c1">// Check whether it holds an object.
</span>  <span class="k">explicit</span> <span class="k">operator</span> <span class="kt">bool</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span> <span class="p">{</span> <span class="k">return</span> <span class="n">ptr_</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">;</span> <span class="p">}</span>

 <span class="k">private</span><span class="o">:</span>
  <span class="n">T</span><span class="o">*</span> <span class="n">ptr_</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">swap</span><span class="p">(</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">b</span><span class="p">)</span> <span class="k">noexcept</span> <span class="p">{</span>
  <span class="n">a</span><span class="p">.</span><span class="n">swap</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
<span class="p">}</span>
</code></pre>
</div>

<p>Let’s dive into the details of the implementation above.</p>

<h3 id="constructors-with-constexpr">Constructors with constexpr</h3>

<p><strong>constexpr</strong> is a new keyword introduced by C++11. One may be confused about
the difference of <strong>constexpr</strong> and the old <strong>const</strong> qualifier at first sight.</p>

<ol>
  <li>
    <p><strong>const</strong> qualifier is used to indicate that an object cannot be modified,
though its value may not be determined until at runtime.</p>
  </li>
  <li>
    <p><strong>constexpr</strong> is used to indicate the value of an object can be determined at
compile time, as well as a constant.</p>
  </li>
</ol>

<p>Hence, <strong>constexpr</strong> is stricter than <strong>const</strong> in that it requires the
qualified object to be a <strong>compile-time constant</strong>. Hence, a <strong>constexpr</strong>
object can be used in template instantiation and array length, where the value
is demanded to be known at compile time.</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">constexpr</span> <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">12</span><span class="p">;</span>         <span class="c1">// a is known to be 12 at compile time.
</span><span class="k">const</span> <span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="n">get_count</span><span class="p">();</span>    <span class="c1">// b cannot be modified, while its value won't be
</span>                              <span class="c1">// known until get_count() returns.
</span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">array</span> <span class="p">{</span>
  <span class="n">T</span> <span class="n">data</span><span class="p">[</span><span class="n">N</span><span class="p">];</span>
<span class="p">};</span>
<span class="n">array</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="n">b</span><span class="o">&gt;</span> <span class="n">foo</span><span class="p">;</span>          <span class="c1">// ERROR! b is not known.
</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="n">a</span><span class="o">&gt;</span> <span class="n">bar</span><span class="p">;</span>          <span class="c1">// OK. a is known.
</span></code></pre>
</div>

<p>Sometimes, the value of an object can be determined at compile time, too. By
specifying <strong>constexpr</strong> before the constructor, the object is regarded as
<strong>constexpr</strong> if all the arguments passed to the constructor are all
<strong>constexpr</strong>. If any argument is otherwise not <strong>constexpr</strong>, the object is not
considered as <strong>constexpr</strong>. Nevertheless, a <strong>constexpr</strong> constructor does not
restrict all its arguments to be <strong>constexpr</strong>.</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">struct</span> <span class="n">add2</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">value</span><span class="p">;</span>
  <span class="k">constexpr</span> <span class="nf">add2</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="o">:</span> <span class="n">value</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">)</span> <span class="p">{}</span>
<span class="p">};</span>
<span class="c1">// We can use the struct as a template argument.
</span><span class="k">constexpr</span> <span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
<span class="n">array</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="n">add2</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="n">k</span><span class="p">).</span><span class="n">value</span><span class="o">&gt;</span> <span class="n">baz</span><span class="p">;</span>   <span class="c1">// The length of baz is 22 floats.
// It can also be used like an ordinary constructor.
</span><span class="kt">int</span> <span class="nf">add</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">add2</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">).</span><span class="n">value</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
</div>

<p>By specifying the two empty constructors of <strong>unique_ptr</strong> to be <strong>constexpr</strong>,
we can create compile-time constants like <code class="highlighter-rouge">unique_ptr&lt;SomeType&gt;()</code> and
<code class="highlighter-rouge">unique_ptr&lt;SomeType&gt;(nullptr)</code>.</p>

<h3 id="keyword-noexcept">Keyword noexcept</h3>

<p>If a function is declared with <strong>noexcept</strong>, it guarantees never throwing
exceptions, so that the compiler can optimize the code based on this knowledge.
Only if all the statements and function calls are certain not to throw
exceptions should a function be declared as <strong>noexcept</strong>.</p>

<p><strong>swap</strong> function is usually implemented as a <strong>noexcept</strong> function in order
that the copy assignment can be exception-safe by applying <a href="/2016/10/16/copy-and-swap.html">Copy and Swap</a>
idiom.</p>

<h3 id="explicitly-deleting-functions">Explicitly deleting functions</h3>

<p>Prior to C++11, it is common to prohibit the copy constructor and copy
assignment operator by declaring them to be <strong>private</strong> members. While, in
C++11, one should prefer deleting them explicitly, because it is not only more
self-explanatory but error-friendly. Furthermore, it can be used with any
overloaded functions to delete some versions. If the deleted function is by
accident called, the compiler will report in a straightforward way instead of
complaining the violation to access permissions.</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="c1">// Any overloaded functions can be deleted.
</span><span class="kt">void</span> <span class="nf">foo</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">}</span>
<span class="kt">void</span> <span class="n">foo</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>   <span class="c1">// Delete the const char* version.
</span>
<span class="kt">void</span> <span class="nf">bar</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">foo</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>         <span class="c1">// OK.
</span>  <span class="n">foo</span><span class="p">(</span><span class="s">"string"</span><span class="p">);</span>   <span class="c1">// Compile error.
</span><span class="p">}</span>
</code></pre>
</div>

<h3 id="explicit-constructor">Explicit constructor</h3>

<p>If an constructor accepts only one argument, it is always a good practice to
declare it with <strong>explicit</strong> in order to prevent unexpected implicit type
conversion.</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">struct</span> <span class="n">Person</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">age</span><span class="p">;</span>
  <span class="n">Person</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">)</span> <span class="o">:</span> <span class="n">age</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="p">{}</span>
<span class="p">};</span>
<span class="kt">void</span> <span class="n">foo</span><span class="p">(</span><span class="k">const</span> <span class="n">Person</span><span class="o">&amp;</span> <span class="n">p</span><span class="p">);</span>
<span class="c1">// Unexpectedly construct a temporary Person object.
</span><span class="n">foo</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">Person</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">age</span><span class="p">;</span>
  <span class="c1">// Prohibit implicit type conversion.
</span>  <span class="k">explicit</span> <span class="nf">Person</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">)</span> <span class="o">:</span> <span class="n">age</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="p">{}</span>
<span class="p">};</span>
<span class="c1">// Cause compile error.
</span><span class="n">foo</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</code></pre>
</div>
<h3 id="move-semantics">Move semantics</h3>

<p>C++11 introduces rvalue references as supplementary to the lvalue references.
Read <a href="/2016/10/24/rvalue-reference.html">Rvalue Reference</a> for details.</p>

<h2 id="upcasting-uniqueptr">Upcasting unique_ptr</h2>

<p>We can assign an object to a pointer that points to its base type, which is
called <strong>upcasting</strong>. However, in the <strong>unique_ptr</strong> above, we cannot upcast a
<strong>unique_ptr</strong> to one that points to the base class, because they are different
types from the compiler’s view. For example, the following code won’t work.</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">struct</span> <span class="n">A</span> <span class="p">{};</span>
<span class="k">struct</span> <span class="n">B</span> <span class="o">:</span> <span class="n">A</span> <span class="p">{};</span>
<span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">B</span><span class="o">&gt;</span> <span class="n">pb</span> <span class="o">=</span> <span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">B</span><span class="o">&gt;</span><span class="p">(</span><span class="k">new</span> <span class="n">B</span><span class="p">);</span>
<span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span> <span class="n">pa</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">pb</span><span class="p">);</span>           <span class="c1">// Compile error.
</span></code></pre>
</div>

<p>In order to upcast a unique_ptr, we add an constructor template that can be used
in implicit type conversions to it.</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="c1">// In the definition of class template unique_ptr
// Implicit type conversions between unique_ptrs.
</span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">U</span><span class="o">&gt;</span>
<span class="n">unique_ptr</span><span class="p">(</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;&amp;&amp;</span> <span class="n">u</span><span class="p">)</span> <span class="k">noexcept</span> <span class="o">:</span> <span class="n">ptr_</span><span class="p">(</span><span class="n">u</span><span class="p">.</span><span class="n">ptr_</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">u</span><span class="p">.</span><span class="n">ptr_</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
</div>

<p>Thus, when we are implicitly converting an object of <strong>unique_ptr&lt;A&gt;</strong> to one
of <strong>unique_ptr&lt;B&gt;</strong>, the compiler will instantiate a constructor from the
template that accepts <strong>unique_ptr&lt;A&gt;</strong> as its argument. Because the compiler
checks types after template instantiation, if A is found not convertible to B,
the compiler will report errors. Otherwise, the conversion will be done.</p>

<p>One may consider the constructor template above as a generalized version for
a move constructor. However, <strong>the move/copy constructors must be explicitly
defined even if a matchable template is given</strong>. That’s because the compiler
will add a default move/copy constructor to the class if one is not found.
However, when checking existing constructors, the compiler won’t go for
templates. Therefore, the move/copy constructors must be explicitly given.
Otherwise, the compiler will provide a default one instead of instantiating a
constructor template.</p>

<h2 id="ownership-releasing">Ownership releasing</h2>

<p>In our <strong>unique_ptr</strong>, the ownership of an object can only be transferred
between <strong>unique_ptr</strong> objects. Sometimes, we need the <strong>unique_ptr</strong> to
release the ownership of the object. For example, when we return the dynamically
allocated object in a C style, we cannot return a smart pointer. Hence, we add a
public method <strong>release</strong> so as to explicitly renounce the ownership.</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="c1">// In the definition of class template unique_ptr
</span><span class="n">T</span><span class="o">*</span> <span class="n">release</span><span class="p">()</span> <span class="k">noexcept</span> <span class="p">{</span>
  <span class="n">T</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="n">ptr_</span><span class="p">;</span>
  <span class="n">ptr_</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">p</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
</div>

<h2 id="custom-deleter">Custom deleter</h2>

<p>In this section, we are going to add custom deleter support to our
implementation by introducing a new template parameter to match the type of the
deleter, which requires passing functions like an object.</p>

<p>The first way that a function can be interpreted as an object in C++ is a
function pointer, which has been a feature since C is born. To mimic the
<strong>deleter</strong> operator, the type of the pointer to a function that accepts a
pointer and returns nothing can be <code class="highlighter-rouge">void (*)(T*)</code>, if <strong>T</strong> is the type of the
object to be released. The asterisk must be enclosed in parentheses, because
otherwise the type <code class="highlighter-rouge">void * (T*)</code> looks like a function that returns <code class="highlighter-rouge">void*</code>.</p>

<p>However, in C++, an object that overloads <strong>operator()</strong> can also be called like
a function, for which reason they are named function objects. Hence, the type of
the deleter function cannot only be a plain function but any class that
overloads <strong>operator()</strong> that accepts a pointer as its argument. Therefore, we
have to introduce a new template parameter so as to accept anything callable in
C++ as a deleter function. Furthermore, we need to provide a default deleter as
well, which releases objects with operator <strong>delete</strong>.</p>

<p>A possible implementation can be:</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="cp">#include &lt;utility&gt;
</span>
<span class="c1">// Default deleter.
</span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">default_delete</span> <span class="p">{</span>
  <span class="kt">void</span> <span class="k">operator</span><span class="p">()(</span><span class="n">T</span><span class="o">*</span> <span class="n">ptr</span><span class="p">)</span> <span class="k">noexcept</span> <span class="p">{</span> <span class="k">delete</span> <span class="n">ptr</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Deleter</span> <span class="o">=</span> <span class="n">default_delete</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span>
<span class="k">class</span> <span class="nc">unique_ptr</span> <span class="p">{</span>
 <span class="k">public</span><span class="o">:</span>
  <span class="c1">// Constructors that makes an empty unique_ptr.
</span>  <span class="k">constexpr</span> <span class="n">unique_ptr</span><span class="p">()</span> <span class="k">noexcept</span> <span class="o">:</span> <span class="n">ptr_</span><span class="p">(</span><span class="nb">nullptr</span><span class="p">),</span> <span class="n">deleter_</span><span class="p">()</span> <span class="p">{}</span>
  <span class="k">constexpr</span> <span class="n">unique_ptr</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">nullptr_t</span><span class="p">)</span> <span class="k">noexcept</span> 
      <span class="o">:</span> <span class="n">ptr_</span><span class="p">(</span><span class="nb">nullptr</span><span class="p">),</span> <span class="n">deleter_</span><span class="p">()</span> <span class="p">{}</span>

  <span class="c1">// Constructor that makes a unique_ptr that holds the given object.
</span>  <span class="k">explicit</span> <span class="n">unique_ptr</span><span class="p">(</span><span class="n">T</span><span class="o">*</span> <span class="n">p</span><span class="p">)</span> <span class="k">noexcept</span> <span class="o">:</span> <span class="n">ptr_</span><span class="p">(</span><span class="n">p</span><span class="p">),</span> <span class="n">deleter_</span><span class="p">()</span> <span class="p">{}</span>

  <span class="c1">// Constructor that accepts a raw pointer and a deleter.
</span>  <span class="n">unique_ptr</span><span class="p">(</span><span class="n">T</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="k">const</span> <span class="n">Deleter</span><span class="o">&amp;</span> <span class="n">d</span><span class="p">)</span> <span class="k">noexcept</span> <span class="o">:</span> <span class="n">ptr_</span><span class="p">(</span><span class="n">p</span><span class="p">),</span> <span class="n">deleter_</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="p">{}</span>
  <span class="n">unique_ptr</span><span class="p">(</span><span class="n">T</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="n">Deleter</span><span class="o">&amp;&amp;</span> <span class="n">d</span><span class="p">)</span> <span class="k">noexcept</span> <span class="o">:</span> <span class="n">ptr_</span><span class="p">(</span><span class="n">p</span><span class="p">),</span> <span class="n">deleter_</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">d</span><span class="p">))</span> <span class="p">{}</span>

  <span class="c1">// Implicit type conversions between unique_ptrs.
</span>  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">U</span><span class="p">,</span> <span class="k">typename</span> <span class="n">E</span><span class="o">&gt;</span>
  <span class="n">unique_ptr</span><span class="p">(</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">U</span><span class="p">,</span> <span class="n">E</span><span class="o">&gt;&amp;&amp;</span> <span class="n">u</span><span class="p">)</span> <span class="k">noexcept</span>
      <span class="o">:</span> <span class="n">ptr_</span><span class="p">(</span><span class="n">u</span><span class="p">.</span><span class="n">ptr_</span><span class="p">),</span> <span class="n">deleter_</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">u</span><span class="p">.</span><span class="n">deleter_</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">u</span><span class="p">.</span><span class="n">ptr_</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// Move constructor. Transfer the object from u to this object.
</span>  <span class="n">unique_ptr</span><span class="p">(</span><span class="n">unique_ptr</span><span class="o">&amp;&amp;</span> <span class="n">u</span><span class="p">)</span> <span class="k">noexcept</span>
      <span class="o">:</span> <span class="n">ptr_</span><span class="p">(</span><span class="n">u</span><span class="p">.</span><span class="n">ptr_</span><span class="p">),</span> <span class="n">deleter_</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">u</span><span class="p">.</span><span class="n">deleter_</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">u</span><span class="p">.</span><span class="n">ptr_</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// Move assignment operator can be implemented by swapping.
</span>  <span class="n">unique_ptr</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">unique_ptr</span><span class="o">&amp;&amp;</span> <span class="n">u</span><span class="p">)</span> <span class="k">noexcept</span> <span class="p">{</span>
    <span class="n">swap</span><span class="p">(</span><span class="n">u</span><span class="p">);</span>
    <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// Swap with another unique_ptr object.
</span>  <span class="kt">void</span> <span class="n">swap</span><span class="p">(</span><span class="n">unique_ptr</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="k">noexcept</span> <span class="p">{</span>
    <span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">;</span>
    <span class="n">swap</span><span class="p">(</span><span class="n">ptr_</span><span class="p">,</span> <span class="n">other</span><span class="p">.</span><span class="n">ptr_</span><span class="p">);</span>
    <span class="n">swap</span><span class="p">(</span><span class="n">deleter_</span><span class="p">,</span> <span class="n">other</span><span class="p">.</span><span class="n">deleter_</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="c1">// Explicitly delete the copy constructor and copy assignment operator.
</span>  <span class="n">unique_ptr</span><span class="p">(</span><span class="k">const</span> <span class="n">unique_ptr</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
  <span class="n">unique_ptr</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">unique_ptr</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>

  <span class="c1">// Destructor.
</span>  <span class="o">~</span><span class="n">unique_ptr</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// Delete the object if the unique_ptr is holding one.
</span>    <span class="k">if</span> <span class="p">(</span><span class="n">ptr_</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">deleter_</span><span class="p">(</span><span class="n">ptr_</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="c1">// Access the object.
</span>  <span class="n">T</span><span class="o">*</span> <span class="n">get</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span> <span class="p">{</span> <span class="k">return</span> <span class="n">ptr_</span><span class="p">;</span> <span class="p">}</span>
  
  <span class="c1">// Access the deleter.
</span>  <span class="n">Deleter</span><span class="o">&amp;</span> <span class="n">get_deleter</span><span class="p">()</span> <span class="k">noexcept</span> <span class="p">{</span> <span class="k">return</span> <span class="n">deleter_</span><span class="p">;</span> <span class="p">}</span>
  <span class="k">const</span> <span class="n">Deleter</span><span class="o">&amp;</span> <span class="n">get_deleter</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span> <span class="p">{</span> <span class="k">return</span> <span class="n">deleter_</span><span class="p">;</span> <span class="p">}</span>

  <span class="c1">// Overloads dereferencing operators so that a unique_ptr resembles a raw
</span>  <span class="c1">// pointer, like *uptr and uptr-&gt;member.
</span>  <span class="n">T</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">*</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span> <span class="p">{</span> <span class="k">return</span> <span class="o">*</span><span class="n">ptr_</span><span class="p">;</span> <span class="p">}</span>
  <span class="n">T</span><span class="o">*</span> <span class="k">operator</span><span class="o">-&gt;</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span> <span class="p">{</span> <span class="k">return</span> <span class="n">ptr_</span><span class="p">;</span> <span class="p">}</span>

  <span class="c1">// Renounce the ownership.
</span>  <span class="n">T</span><span class="o">*</span> <span class="n">release</span><span class="p">()</span> <span class="k">noexcept</span> <span class="p">{</span>
    <span class="n">T</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="n">ptr_</span><span class="p">;</span>
    <span class="n">ptr_</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">p</span><span class="p">;</span>
  <span class="p">}</span>

 <span class="k">private</span><span class="o">:</span>
  <span class="n">T</span><span class="o">*</span> <span class="n">ptr_</span><span class="p">;</span>
  <span class="n">Deleter</span> <span class="n">deleter_</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">D</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">swap</span><span class="p">(</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">D</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">D</span><span class="o">&gt;&amp;</span> <span class="n">b</span><span class="p">)</span> <span class="k">noexcept</span> <span class="p">{</span>
  <span class="n">a</span><span class="p">.</span><span class="n">swap</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
<span class="p">}</span>
</code></pre>
</div>

<p>However, there is a special case that the type of the deleter is a lvalue
reference. Anyway, the definition above does not prohibit a user from
instantiating a <strong>unique_ptr</strong> with Deleter being <code class="highlighter-rouge">A&amp;</code>.</p>

<p>In the definition above, we assume the type of the deleter is a non-reference,
hence we provide two constructors that accept lvalue-references and
rvalue-references, respectively. However, if <strong>Deleter</strong> itself is a lvalue
reference <code class="highlighter-rouge">A&amp;</code>, the two constructors will become the one that accepts <code class="highlighter-rouge">const A&amp;</code>
and the other <code class="highlighter-rouge">A&amp;</code> because of reference collapsing. Even worse, the constructor
that accepts <code class="highlighter-rouge">A&amp;</code>, which is collapsed from rvalue reference, will mistakenly
move the deleter from the given object, even if the reference passed to it is
actually a lvalue reference. Furthermore, if <strong>Deleter</strong> itself is <code class="highlighter-rouge">const A&amp;</code>,
the two constructors will have exactly the same signature. The following code
demonstrates the problem:</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="c1">// The prototypes of the two constructors if T = A and Deleter = SomeDeleter&amp;.
// This constructor will violate the constness of the given argument.
</span><span class="n">unique_ptr</span><span class="p">(</span><span class="n">A</span><span class="o">*</span> <span class="n">ptr</span><span class="p">,</span> <span class="k">const</span> <span class="n">SomeDeleter</span><span class="o">&amp;</span> <span class="n">d</span><span class="p">);</span> 
<span class="c1">// This constructor will cast d to a rvalue reference by std::move.
</span><span class="n">unique_ptr</span><span class="p">(</span><span class="n">A</span><span class="o">*</span> <span class="n">ptr</span><span class="p">,</span> <span class="n">SomeDeleter</span><span class="o">&amp;</span> <span class="n">d</span><span class="p">);</span> 

<span class="c1">// The prototypes of the two constructors if T = A and
// Deleter = const SomeDeleter&amp;.
</span><span class="n">unique_ptr</span><span class="p">(</span><span class="n">A</span><span class="o">*</span> <span class="n">ptr</span><span class="p">,</span> <span class="k">const</span> <span class="n">SomeDeleter</span><span class="o">&amp;</span> <span class="n">d</span><span class="p">);</span>
<span class="n">unique_ptr</span><span class="p">(</span><span class="n">A</span><span class="o">*</span> <span class="n">ptr</span><span class="p">,</span> <span class="k">const</span> <span class="n">SomeDeleter</span><span class="o">&amp;</span> <span class="n">d</span><span class="p">);</span>
</code></pre>
</div>

<p>Hence, the situation that Deleter is a lvalue reference must be carefully
treated. We can look up in the C++ reference to find out how STL deals with it:</p>

<p>If Deleter is lvalue reference <code class="highlighter-rouge">A&amp;</code>:</p>

<ol>
  <li>the first constructor accepts <code class="highlighter-rouge">A&amp;</code>;</li>
  <li>the second constructor accepts <code class="highlighter-rouge">A&amp;&amp;</code>.</li>
</ol>

<p>Still further, if Deleter is lvalue reference <code class="highlighter-rouge">const A&amp;</code>:</p>

<ol>
  <li>the first constructor accepts <code class="highlighter-rouge">const A&amp;</code>;</li>
  <li>the second constructor accepts <code class="highlighter-rouge">const A&amp;&amp;</code>.</li>
</ol>

<p>Since we have known the direction, now we need to implement the rule in
practice. The second constructor is easy to define, for it accepts a rvalue
reference in spite of whether Deleter is a reference and the constness is the
same as Deleter. All that we need to do is to strip the reference part and
append the rvalue reference symbol <strong>&amp;&amp;</strong> to it.</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="c1">// Include type_traits in order to use std::remove_reference.
</span><span class="cp">#include &lt;type_traits&gt;
</span><span class="n">unique_ptr</span><span class="p">(</span><span class="n">T</span><span class="o">*</span><span class="p">,</span> <span class="k">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">remove_reference</span><span class="o">&lt;</span><span class="n">Deleter</span><span class="o">&gt;::</span><span class="n">type</span><span class="o">&amp;&amp;</span> <span class="n">d</span><span class="p">)</span> <span class="k">noexcept</span>
    <span class="o">:</span> <span class="n">ptr_</span><span class="p">(</span><span class="n">u</span><span class="p">.</span><span class="n">ptr_</span><span class="p">),</span> <span class="n">deleter_</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">d</span><span class="p">))</span> <span class="p">{}</span>
</code></pre>
</div>

<p>The tricky one is the first constructor, because it adds the <strong>const</strong> qualifier
only if Deleter is a non-reference. If Deleter is otherwise a lvalue reference,
the type of the argument has the same constness as Deleter. Therefore, we need a
conditional expression on types, which is exactly what <strong>std::conditional&lt;B, T,
F&gt;</strong> is used for.</p>

<p><strong>std::conditional&lt;B, T, F&gt;</strong> accepts a compile-time boolean constant <strong>B</strong> and
two types <strong>T</strong> and <strong>F</strong>. If <strong>B</strong> is true, the type member <strong>type</strong> will be
<strong>T</strong>. Otherwise, the type member will be <strong>F</strong>.</p>

<p>To check if a given type is a lvalue reference, we can use
<strong>std::is_lvalue_reference&lt;T&gt;</strong>, whose constant data member <strong>value</strong> is true
if <strong>T</strong> is a lvalue reference.</p>

<p>Hence, we can define the first constructor as:</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="n">unique_ptr</span><span class="p">(</span>
  <span class="n">T</span><span class="o">*</span><span class="p">,</span> 
  <span class="k">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">conditional</span><span class="o">&lt;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">is_lvalue_reference</span><span class="o">&lt;</span><span class="n">Deleter</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">,</span>
    <span class="n">Deleter</span><span class="p">,</span> 
    <span class="k">const</span> <span class="n">Deleter</span><span class="o">&gt;::</span><span class="n">type</span><span class="o">&amp;</span> <span class="n">d</span><span class="p">)</span> <span class="k">noexcept</span> <span class="o">:</span> <span class="n">ptr_</span><span class="p">(</span><span class="n">u</span><span class="p">.</span><span class="n">ptr_</span><span class="p">),</span> <span class="n">deleter_</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="p">{}</span>
</code></pre>
</div>

<p>Now our <strong>unique_ptr</strong> is finally friendly to lvalue references. So what about a
rvalue reference <strong>D&amp;&amp;</strong>? Following the reference collapsing rule, the
prototypes of the two constructors are:</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="c1">// This constructor will cause compile error if it is used in practice, because
// you cannot bind a lvalue to a rvalue reference.
</span><span class="n">unique_ptr</span><span class="p">(</span><span class="n">T</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="k">const</span> <span class="n">D</span><span class="o">&amp;</span> <span class="n">d</span><span class="p">);</span>
<span class="c1">// This is the version that can be actually used in practice.
</span><span class="n">unique_ptr</span><span class="p">(</span><span class="n">T</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="n">D</span><span class="o">&amp;&amp;</span> <span class="n">d</span><span class="p">);</span>
</code></pre>
</div>

<p>Therefore, the implementation above works fine with rvalue references.</p>

<h2 id="some-more-details">Some more details</h2>

<p>Although we have covered the most important parts of a <strong>unique_ptr</strong>, there are
still some features that we ignore, for example, the <strong>make_unique</strong> utility
function, comparison operators between two <strong>unique_ptr</strong>s and the hash
function. Since they are quite straightforward compared to the other features,
they can be easily understood by reaching up to the reference.</p>


  </div>

  
    

  
</article>




      </div>
    </main>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">tding.in <small><a href="/feed.xml">via RSS</a></small></h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li>
          
            Thomas Ding
          
          </li>
          
          <li><a href="mailto:thomasbyding@gmail.com">thomasbyding@gmail.com</a></li>
          
          
          <li>
            <a href="https://github.com/thomasding"><span class="icon icon--github"><svg viewBox="0 0 16 16" width="16px" height="16px"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span><span class="username">thomasding</span></a>

          </li>
          
          
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <p>Covering instruction-level optimization, C++ features, best practices and so many other interesting topics.
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
