<!DOCTYPE html>
<html lang="en">

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>unique_ptr, shared_ptr and weak_ptr</title>
  <meta name="description" content="Smart pointers are one of the most enchanting features that C++11 provides. Using smart pointers, it’s possible that you will never need to remember freeing ...">

  <link rel="stylesheet" href="/assets/main.css">
  <link rel="canonical" href="http://tding.in/2016/11/20/unique-ptr-shared-ptr-and-weak-ptr.html">
  <link rel="alternate" type="application/rss+xml" title="tding.in" href="/feed.xml">
  
  
</head>


  <body>

    <header class="site-header" role="banner">

  <div class="wrapper">

    <a class="site-title" href="/">tding.in</a>

    <nav class="site-nav">
      <span class="menu-icon">
        <svg viewBox="0 0 18 15" width="18px" height="15px">
          <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
          <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
          <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
        </svg>
      </span>

      <div class="trigger">
        
        
          
        
          
        
          
        
          
        
          
          <a class="page-link" href="/archive/">Archive</a>
          
        
          
          <a class="page-link" href="/tags/">Tags</a>
          
        
      </div>
    </nav>

  </div>

</header>


    <main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">unique_ptr, shared_ptr and weak_ptr</h1>
    <div class="post-meta">
      <time datetime="2016-11-20T00:00:00+08:00" itemprop="datePublished">Nov 20, 2016</time>
      <ul class="post-tags post-meta">
        
        <li>
          <a href="/tags/#c++" class="post-tag">c++</a>
        </li>
        
      </ul>
    </div>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p>Smart pointers are one of the most enchanting features that C++11 provides.
Using smart pointers, it’s possible that you will never need to remember freeing
a dynamically allocated object any more. However, C++11 provides three kinds of
smart pointers together. It’s important that you use the right one in practice.</p>

<!--more-->

<h2 id="uniqueptr">unique_ptr</h2>

<p>A unique_ptr should be the first that comes to your mind when you need to
dynamically allocate an object.</p>

<p>In comparison to a raw pointer, a unique_ptr has no space overhead if you don’t
specify a custom deleter, which means it occupies the same space as a raw
pointer. Furthermore, with the help of function inlining, a unique_ptr has no
time overhead compared to a raw pointer. Therefore, a unique_ptr is a perfect
replacement to a raw pointer, which should be the first to consider.</p>

<p>As is its name suggested, a unique_ptr owns a object uniquely, that is, the
unique_ptr can be moved, but not copied.</p>

<p>Here are some examples of using unique_ptrs.</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">User</span><span class="p">;</span>

<span class="c1">// Return a unique_ptr to extend the life time of the object out of the 
// function scope.
</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">User</span><span class="o">&gt;</span> <span class="n">create_user</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">name</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">auto</span> <span class="n">user</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">User</span><span class="o">&gt;</span><span class="p">(</span><span class="k">new</span> <span class="n">User</span><span class="p">(</span><span class="n">name</span><span class="p">));</span>
    <span class="c1">// Do something to user.
</span>    <span class="c1">// If you return a local variable, it's moved rather than copied.
</span>    <span class="k">return</span> <span class="n">user</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Hold a local object by its base type.
</span><span class="k">class</span> <span class="nc">Admin</span><span class="o">:</span> <span class="k">public</span> <span class="n">User</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">};</span>
<span class="k">class</span> <span class="nc">Visitor</span><span class="o">:</span> <span class="k">public</span> <span class="n">User</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">};</span>
<span class="kt">void</span> <span class="nf">add_user</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">name</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">type</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">User</span><span class="o">&gt;</span> <span class="n">user</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="s">"admin"</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">user</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Admin</span><span class="o">&gt;</span><span class="p">(</span><span class="k">new</span> <span class="n">Admin</span><span class="p">(</span><span class="n">name</span><span class="p">));</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">user</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Visitor</span><span class="o">&gt;</span><span class="p">(</span><span class="k">new</span> <span class="n">Visitor</span><span class="p">(</span><span class="n">name</span><span class="p">));</span>
    <span class="p">}</span>
    <span class="c1">// Do something to user.
</span>    <span class="c1">// When the function returns, the user object will be
</span>    <span class="c1">// automatically freed.
</span><span class="p">}</span>

<span class="c1">// Hold a data member in a class by its base type.
</span><span class="k">class</span> <span class="nc">Post</span> <span class="p">{</span>
    <span class="c1">// ...
</span><span class="nl">private:</span>
    <span class="c1">// When the Post object is freed, the user_ object will be
</span>    <span class="c1">// automatically freed.
</span>    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">User</span><span class="o">&gt;</span> <span class="n">user_</span><span class="p">;</span>   <span class="c1">// May be Admin or Visitor.
</span><span class="p">};</span>
</code></pre>
</div>

<p>To pass a unique_ptr-held object to a function, you should avoid passing value,
for unique_ptr cannot be copied (in C++ terms, a unique_ptr is not copy
constructible or copy assignable). Instead, you should pass
lvalue-reference-to-const of the unique_ptr or that of the object being held.
The latter is preferred, because the function should not know if the object is
being held by a unique_ptr or a shared_ptr. If the object may be a nullptr,
you should consider passing a raw pointer. A raw pointer is safe to use as long
as it does not own the object that it points to (“A owns B” means A is
responsible to free B).</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="c1">// Compile error most of the time, unless you moves the unique_ptr to the
// function.
// void foo(std::unique_ptr&lt;Object&gt; p);
</span>
<span class="c1">// Preferred method. But obj cannot be bound to a nullptr.
</span><span class="kt">void</span> <span class="n">foo</span><span class="p">(</span><span class="k">const</span> <span class="n">Object</span><span class="o">&amp;</span> <span class="n">obj</span><span class="p">);</span>
<span class="c1">// Preferred, too, if the object may be nullptr.
</span><span class="kt">void</span> <span class="n">foo</span><span class="p">(</span><span class="k">const</span> <span class="n">Object</span><span class="o">*</span> <span class="n">pobj</span><span class="p">);</span>
<span class="c1">// Not preferred, but okay.
</span><span class="kt">void</span> <span class="n">foo</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Object</span><span class="o">&gt;&amp;</span> <span class="n">p</span><span class="p">);</span>
<span class="c1">// Okay if the function modifies obj.
</span><span class="kt">void</span> <span class="n">foo</span><span class="p">(</span><span class="n">Object</span><span class="o">&amp;</span> <span class="n">obj</span><span class="p">);</span>
<span class="c1">// Explicitly indicates that the ownership of the object
// should be transferred to the function.
</span><span class="kt">void</span> <span class="n">foo</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Object</span><span class="o">&gt;&amp;&amp;</span> <span class="n">p</span><span class="p">);</span>
</code></pre>
</div>

<p>A unique_ptr overloads <strong>operator*</strong> and <strong>operator-&gt;</strong> so that it can be
dereferenced like a pointer. It also provides a public method <strong>get</strong> to return
the raw pointer.</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">struct</span> <span class="n">Box</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">width</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">height</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="n">foo</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Box</span><span class="o">&gt;&amp;</span> <span class="n">pbox</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Like pointers.
</span>    <span class="n">pbox</span><span class="o">-&gt;</span><span class="n">width</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
    <span class="n">Box</span><span class="o">&amp;</span> <span class="n">box</span> <span class="o">=</span> <span class="o">*</span><span class="n">pbox</span><span class="p">;</span>
    <span class="c1">// Get the raw pointer.
</span>    <span class="n">Box</span><span class="o">*</span> <span class="n">box</span> <span class="o">=</span> <span class="n">pbox</span><span class="p">.</span><span class="n">get</span><span class="p">();</span>
<span class="p">}</span>
</code></pre>
</div>

<p>A unique_ptr, in addition, provides a public method <strong>release</strong> that returns
the raw pointer and renounces the ownership of the object, that is, the receiver
of the raw pointer is responsible to release the object. It is useful if you are
implementing a C interface, where a function cannot return a smart pointer.</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">extern</span> <span class="s">"C"</span> <span class="n">Box</span><span class="o">*</span> <span class="n">new_box</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">auto</span> <span class="n">box</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">unique</span><span class="err">\</span><span class="n">_ptr</span><span class="o">&lt;</span><span class="n">Box</span><span class="o">&gt;</span><span class="p">(</span><span class="k">new</span> <span class="n">Box</span><span class="p">);</span>
    <span class="c1">// The following to functions that calculates the height and width of the
</span>    <span class="c1">// box, respectively, may throw exceptions.
</span>    <span class="n">box</span><span class="o">-&gt;</span><span class="n">width</span> <span class="o">=</span> <span class="n">calculate_width</span><span class="p">();</span>
    <span class="n">box</span><span class="o">-&gt;</span><span class="n">height</span> <span class="o">=</span> <span class="n">calculate_height</span><span class="p">();</span>
    <span class="k">return</span> <span class="n">box</span><span class="o">-&gt;</span><span class="n">release</span><span class="p">();</span>
<span class="p">}</span>
</code></pre>
</div>

<p>It is exception-safe inside the function by using unique_ptr inside a function
and releasing it in the end. If an exception is thrown before it is released,
the object will be properly deallocated.</p>

<p>In addition to be a smart pointer, a unique_ptr can use a custom deleter in
place of <code class="highlighter-rouge">delete</code> to free the object, the type of which is the second template
parameter.</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="c1">// The object of a simple class/struct that overloads operator() is usually
// called a functional object.
</span><span class="k">struct</span> <span class="n">MyCustomDeleter</span> <span class="p">{</span>
    <span class="kt">void</span> <span class="k">operator</span><span class="p">()(</span><span class="n">Box</span><span class="o">*</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// Deallocate the object pointed by p, like:
</span>        <span class="c1">// delete p;
</span>    <span class="p">}</span>
<span class="p">};</span>
<span class="kt">void</span> <span class="n">my_custom_deleter</span><span class="p">(</span><span class="n">Box</span><span class="o">*</span> <span class="n">p</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">foo</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">auto</span> <span class="n">pbox</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Box</span><span class="p">,</span> <span class="n">MyCustomDeleter</span><span class="o">&gt;</span><span class="p">(</span><span class="k">new</span> <span class="n">Box</span><span class="p">);</span>
<span class="p">}</span>
</code></pre>
</div>

<h2 id="sharedptr">shared_ptr</h2>

<p>A shared_ptr should be used in situations where an object is held by many
owners, and the last owner that releases it is responsible to deallocate it.
Typically, a shared_ptr occupies the size of two pointers, one pointing to the
object and the other to a shared block that contains the reference count and
custom deleter bound to the object, called a control block.</p>

<figure class="figure">
    <object data="/assets/posts/2016-11-20-unique-ptr-shared-ptr-and-weak-ptr/shared_ptr.svg" type="image/svg+xml">
        <img src="/assets/posts/2016-11-20-unique-ptr-shared-ptr-and-weak-ptr/shared_ptr.png" />
    </object>
    <figcaption>The diagram of shared_ptrs</figcaption>
</figure>

<p>Compared to a unique_ptr, a shared_ptr not only brings about additional space
overhead, but time cost. Each time a shared_ptr is copied or destroyed, the
reference count must be increased or decreased, respectively.</p>

<p>Except for the mentioned difference between unique_ptrs and shared_ptrs, the
usage are mostly the same.</p>

<h2 id="weakptr">weak_ptr</h2>

<p>A weak_ptr is used to hold an object without affecting the reference count.
It must be converted to a shared_ptr before accessing the object being held.
The object will be freed as soon as the last shared_ptr is destroyed, in spite
of existing weak_ptrs.</p>

<p>A weak_ptr is usually used to:</p>

<ol>
  <li>keep a cache of object;</li>
  <li>break circular dependencies.</li>
</ol>

<p>To distinguish from reference count, the number of weak_ptrs is recorded in the
control block as the weak count. When the reference count reaches zero, the
object being held is deallocated, while the control block remains existing till
the weak count also decreases to zero.</p>

<p>A weak_ptr has to be converted into a shared_ptr before accessing the object.
If the object has been freed, the conversion throws an exception or returns a
null shared_ptr.</p>

<p>Here is a simple example of using weak_ptr to cache results.</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Account</span> <span class="p">{</span> <span class="cm">/* .. */</span> <span class="p">};</span>
<span class="c1">// A time consuming operation to lookup an account from a database.
</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Account</span><span class="o">&gt;</span> <span class="n">get_account_from_db</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">name</span><span class="p">);</span>

<span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">weak_ptr</span><span class="o">&lt;</span><span class="n">Account</span><span class="o">&gt;&gt;</span> <span class="n">cache</span><span class="p">;</span>
<span class="c1">// Cache the result without affecting reference counts.
</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Account</span><span class="o">&gt;</span> <span class="n">get_account</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">name</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">auto</span> <span class="n">cached_pair</span> <span class="o">=</span> <span class="n">cache</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">name</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">cached_pair</span> <span class="o">!=</span> <span class="n">cache</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Account</span><span class="o">&gt;</span> <span class="n">ptr</span> <span class="o">=</span> <span class="n">cached_pair</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">.</span><span class="n">lock</span><span class="p">();</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">ptr</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">ptr</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Account</span><span class="o">&gt;</span> <span class="n">ptr</span> <span class="o">=</span> <span class="n">get_account_from_db</span><span class="p">(</span><span class="n">name</span><span class="p">);</span>
    <span class="n">cache</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">weak_ptr</span><span class="o">&lt;</span><span class="n">Account</span><span class="o">&gt;</span><span class="p">(</span><span class="n">ptr</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">ptr</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
</div>

<h2 id="dont-abuse-smart-pointers">Don’t abuse smart pointers</h2>

<p>Smart pointers may be abused, shared_ptr particularly. As a good habit, you
should keep the use of smart pointers as few as possible, especially
shared_ptrs and weak_ptrs.</p>

<h3 id="scenario-1-as-function-arguments">Scenario 1: as function arguments</h3>

<p>If the function is not responsible to free the object, that is, it only accesses
or modifies it, it is better to pass a lvalue reference (or lvalue reference to
const) to the function. If the object is optional, passing a raw pointer (or
pointer to const) is also okay. If the smart pointer is necessary, prefer
passing by lvalue reference to by value, because unique_ptr cannot be passed by
value, and copying shared_ptrs brings about time overhead.</p>

<p>This scenario is covered in the unique_ptr section.</p>

<h3 id="scenario-2-as-data-members">Scenario 2: as data members</h3>

<p>Storing as non-pointer is the first choice. When it comes to polymorphic types,
consider unique_ptr at first.</p>

<p>If many objects keep a pointer to the object, it seems plausible to use
shared_ptrs at first sight, but actually not. Like the following example, each
UI components hold a shared_ptr of the Drawer object.</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="c1">// Bad design.
</span><span class="k">class</span> <span class="nc">Drawer</span><span class="p">;</span>
<span class="k">class</span> <span class="nc">NaiveDrawer</span><span class="o">:</span> <span class="n">Drawer</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">};</span>
<span class="k">class</span> <span class="nc">FastDrawer</span><span class="o">:</span> <span class="n">Drawer</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">};</span>

<span class="k">class</span> <span class="nc">ToolBar</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Drawer</span><span class="o">&gt;</span> <span class="n">drawer</span><span class="p">;</span>
    <span class="c1">// ...
</span><span class="p">};</span>
<span class="k">class</span> <span class="nc">Panel</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Drawer</span><span class="o">&gt;</span> <span class="n">drawer</span><span class="p">;</span>
    <span class="c1">// ...
</span><span class="p">};</span>
<span class="k">class</span> <span class="nc">StatusBar</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Drawer</span><span class="o">&gt;</span> <span class="n">drawer</span><span class="p">;</span>
    <span class="c1">// ...
</span><span class="p">};</span>
<span class="k">class</span> <span class="nc">Window</span> <span class="p">{</span>
    <span class="n">ToolBar</span> <span class="n">toolbar</span><span class="p">;</span>
    <span class="n">Panel</span> <span class="n">panel</span><span class="p">;</span>
    <span class="n">StatusBar</span> <span class="n">statusbar</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Drawer</span><span class="o">&gt;</span> <span class="n">drawer</span><span class="p">;</span>
    <span class="c1">// ...
</span><span class="p">};</span>
</code></pre>
</div>

<p>Semantically, ToolBar, Panel and StatusBar are all components of Window, so the
life time of a Window object covers that of ToolBar, Panel and StatusBar
objects. Theoretically, the drawer is managed by the window, while the
components only use it, not own it. Therefore, the drawer object should be held
by the Window class by a unique_ptr, while the components hold a reference or
raw pointer.</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="c1">// Good design.
</span><span class="k">class</span> <span class="nc">Drawer</span><span class="p">;</span>
<span class="k">class</span> <span class="nc">NaiveDrawer</span><span class="o">:</span> <span class="n">Drawer</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">};</span>
<span class="k">class</span> <span class="nc">FastDrawer</span><span class="o">:</span> <span class="n">Drawer</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">};</span>

<span class="k">class</span> <span class="nc">ToolBar</span> <span class="p">{</span>
    <span class="n">Drawer</span><span class="o">*</span> <span class="n">drawer</span><span class="p">;</span>
    <span class="c1">// ...
</span><span class="p">};</span>
<span class="k">class</span> <span class="nc">Panel</span> <span class="p">{</span>
    <span class="n">Drawer</span><span class="o">*</span> <span class="n">drawer</span><span class="p">;</span>
    <span class="c1">// ...
</span><span class="p">};</span>
<span class="k">class</span> <span class="nc">StatusBar</span> <span class="p">{</span>
    <span class="n">Drawer</span><span class="o">*</span> <span class="n">drawer</span><span class="p">;</span>
    <span class="c1">// ...
</span><span class="p">};</span>
<span class="k">class</span> <span class="nc">Window</span> <span class="p">{</span>
    <span class="n">ToolBar</span> <span class="n">toolbar</span><span class="p">;</span>
    <span class="n">Panel</span> <span class="n">panel</span><span class="p">;</span>
    <span class="n">StatusBar</span> <span class="n">statusbar</span><span class="p">;</span>
    <span class="c1">// Prefer unique_ptr to shared_ptr.
</span>    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Drawer</span><span class="o">&gt;</span> <span class="n">drawer</span><span class="p">;</span>
    <span class="c1">// ...
</span><span class="p">};</span>
</code></pre>
</div>

  </div>

  
    

  
</article>




      </div>
    </main>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">tding.in <small><a href="/feed.xml">via RSS</a></small></h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li>
          
            Thomas Ding
          
          </li>
          
          <li><a href="mailto:thomasbyding@gmail.com">thomasbyding@gmail.com</a></li>
          
          
          <li>
            <a href="https://github.com/thomasding"><span class="icon icon--github"><svg viewBox="0 0 16 16" width="16px" height="16px"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span><span class="username">thomasding</span></a>

          </li>
          
          
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <p>Covering instruction-level optimization, C++ features, best practices and so many other interesting topics.
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
