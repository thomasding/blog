<!DOCTYPE html>
<html lang="en">

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Copy and Swap</title>
  <meta name="description" content="Copy-and-swap idiom is frequently used to implement a copy assignment operator. If an exception is thrown during copy assignment, it may cause some data memb...">

  <link rel="stylesheet" href="/assets/main.css">
  <link rel="canonical" href="http://localhost:4000/2016/10/16/copy-and-swap.html">
  <link rel="alternate" type="application/rss+xml" title="Tomatoast&#39;s Recipes" href="/feed.xml">
  
  
</head>


  <body>

    <header class="site-header" role="banner">

  <div class="wrapper">

    <a class="site-title" href="/">Tomatoast&#39;s Recipes</a>

    <nav class="site-nav">
      <span class="menu-icon">
        <svg viewBox="0 0 18 15" width="18px" height="15px">
          <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
          <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
          <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
        </svg>
      </span>

      <div class="trigger">
        
        
          
        
          
        
          
        
          
        
          
          <a class="page-link" href="/archive/">Archive</a>
          
        
          
          <a class="page-link" href="/tags/">Tags</a>
          
        
      </div>
    </nav>

  </div>

</header>


    <main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">Copy and Swap</h1>
    <div class="post-meta">
      <time datetime="2016-10-16T00:00:00+08:00" itemprop="datePublished">Oct 16, 2016</time>
      <ul class="post-tags post-meta">
        
        <li>
          <a href="/tags/#c++" class="post-tag">c++</a>
        </li>
        
        <li>
          <a href="/tags/#exception-safe" class="post-tag">exception-safe</a>
        </li>
        
      </ul>
    </div>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p>Copy-and-swap idiom is frequently used to implement a copy assignment operator.</p>

<p>If an exception is thrown during copy assignment, it may cause some data members
to remain unchanged while some others already assigned to new values. In
order to ensure that the object to be copied to be in the original value if an
exception is thrown, we first <strong>create a temporary object by calling its copy
constructor with the object to be copied from, and then swap the contents of the
temporary object with the destination object</strong>. Swap is required to be a
no-failure operation, that is, it always succeeds and never throws exceptions. 
Considering swap is always implemented by interchanging pointers and primitive
variables, it is easy to satisfy the requirement. If an exception is thrown in
the copy step, the temporary object is properly freed, and the destination
object keeps its original value.</p>

<!--more-->

<h2 id="copy-and-swap-by-example">Copy-and-swap by example</h2>

<p>The following copy assignment operator suffers from exception damage.</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">User</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">User</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">name</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">address</span><span class="p">)</span><span class="o">:</span>
        <span class="n">name_</span><span class="p">(</span><span class="n">name</span><span class="p">),</span> <span class="n">address_</span><span class="p">(</span><span class="n">address</span><span class="p">)</span> <span class="p">{}</span>
    <span class="n">User</span><span class="p">(</span><span class="k">const</span> <span class="n">User</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span><span class="o">:</span> <span class="n">name_</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">name_</span><span class="p">),</span> <span class="n">address_</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">address_</span><span class="p">)</span> <span class="p">{}</span>
    <span class="n">User</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">User</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">name_</span> <span class="o">=</span> <span class="n">other</span><span class="p">.</span><span class="n">name_</span><span class="p">;</span>
        <span class="n">address_</span> <span class="o">=</span> <span class="n">other</span><span class="p">.</span><span class="n">address_</span><span class="p">;</span>   <span class="c1">// Consider an exception is thrown here.
</span>        <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// Omit getters and setters ...
</span><span class="nl">private:</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name_</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">address_</span><span class="p">;</span>
<span class="p">};</span>
</code></pre>
</div>

<p>By applying copy-and-swap idiom, the object will keep its original value if an
exception is thrown in the copying assignment operator.</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">User</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">User</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">name</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">address</span><span class="p">)</span><span class="o">:</span>
        <span class="n">name_</span><span class="p">(</span><span class="n">name</span><span class="p">),</span> <span class="n">address_</span><span class="p">(</span><span class="n">address</span><span class="p">)</span> <span class="p">{}</span>
    <span class="n">User</span><span class="p">(</span><span class="k">const</span> <span class="n">User</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span><span class="o">:</span> <span class="n">name_</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">name_</span><span class="p">),</span> <span class="n">address_</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">address_</span><span class="p">)</span> <span class="p">{}</span>
    <span class="n">User</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">User</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// If an exception is thrown, *this will not be modified.
</span>        <span class="n">User</span> <span class="n">tmp</span><span class="p">(</span><span class="n">other</span><span class="p">);</span>
        <span class="n">swap</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span> 
        <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kt">void</span> <span class="n">swap</span><span class="p">(</span><span class="n">User</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">;</span>
        <span class="n">swap</span><span class="p">(</span><span class="n">name_</span><span class="p">,</span> <span class="n">other</span><span class="p">.</span><span class="n">name_</span><span class="p">);</span>
        <span class="n">swap</span><span class="p">(</span><span class="n">address_</span><span class="p">,</span> <span class="n">other</span><span class="p">.</span><span class="n">address_</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="c1">// Omit getters and setters ...
</span><span class="nl">private:</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name_</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">address_</span><span class="p">;</span>
<span class="p">};</span>
<span class="kt">void</span> <span class="nf">swap</span><span class="p">(</span><span class="n">User</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="n">User</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">a</span><span class="p">.</span><span class="n">swap</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
<span class="p">}</span>
</code></pre>
</div>

<h2 id="the-right-way-to-define-a-swap-function">The right way to define a swap function</h2>

<p>In the code above, you may find some interesting places in the implementation, like:</p>

<ol>
  <li>calling std::swap to interchange the data members;</li>
  <li>defining swap as a a public method as well as a non-member function;</li>
  <li><code class="highlighter-rouge">using std::swap</code> at the beginning of our own swap.</li>
</ol>

<p>Most STL containers and objects has its own public member swap as well as a
non-member function one. When we are defining our own swap function, we’d
better conform to this convention. The advantage of defining the extraneous
non-member swap is taken when implementing a template.</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">template</span><span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">rotate</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">,</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">c</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">;</span>
    <span class="n">swap</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>
    <span class="n">swap</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
<span class="p">}</span>
</code></pre>
</div>

<p>In the function above, if T is deduced to be a STL container, the non-member swap
of the container is called. If T is deduced to be our own type, for example,
User, our non-member swap function is called instead. If T is deduced to be a
primitive type, such as int, the std::swap template is instantiated.</p>

<p>It may seem weird to place <code class="highlighter-rouge">using std::swap</code> at the beginning of the function.
Calling std::swap is the first impression that comes to our mind, like the
following version:</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">template</span><span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">rotate</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">,</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">c</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
<span class="p">}</span>
</code></pre>
</div>

<p>Unluckily, the latter version is wrong. Long story short, <strong>always put <code class="highlighter-rouge">using
std::swap</code> before calling swap and call it without any namespace qualifiers</strong>.
The reason why we should not use the namespace-qualified swap (one with <code class="highlighter-rouge">std::</code>
prefix) is a C++ name lookup rule named <strong>argument-dependent lookup</strong>,
abbreviated as <strong>ADL</strong>.</p>

<h2 id="the-right-way-to-call-a-swap-function">The right way to call a swap function</h2>

<p>Curious readers may have found that in the implementation of User, we define
the non-member swap function in our own namespace, outside of namespace std.
So how does the compiler determine which namespace to lookup when a call to swap
is found?</p>

<p><strong>ADL</strong> makes the compiler to lookup the namespaces of the arguments first for
the function in addition to the current scope and namespaces.</p>

<p>To understand ADL, let’s look at a very common scenario making use of this rule:</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="cp">#include &lt;iostream&gt;
</span><span class="k">namespace</span> <span class="n">myns</span> <span class="p">{</span>
  <span class="kt">void</span> <span class="n">print</span><span class="p">()</span> <span class="p">{</span>
      <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>

<p>We are calling operator&lt;&lt; in the function, but <code class="highlighter-rouge">operator&lt;&lt;(ostream&amp;, int)</code> was
not defined in namespace myns and we didn’t use namespace std either.
However, the code is compiled successfully, because the compiler tries to find
operator&lt;&lt; in the namespaces of the arguments, namely, std, and there it
finds the definition.</p>

<p>Back to our call to swap, using the unqualified swap, the compiler will try to
find the definition in the namespaces of the arguments, where the
object-specific swap is usually defined. But there are cases that the swap
template in namespace std is used, for example, for primitive types and those
who don’t have their own swap function, we have to put <code class="highlighter-rouge">using std::swap</code> so that
the compiler will find it in namespace std.</p>

<p>If we use the std::swap version, only the swap template defined in namespace
std is called. However, it will result in our swap function to be called
twice. What? I’ve heard you say. Here, let’s have a look at the default version
of std::swap to figure it out.</p>

<h2 id="how-is-stdswap-implemented">How is std::swap implemented</h2>

<p>Two versions of swap are provided by STL, one for generalized types,
and the other specifically for arrays.</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="c1">// Defined in &lt;utility&gt;
</span><span class="k">template</span><span class="o">&lt;</span> <span class="k">class</span> <span class="nc">T</span> <span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">swap</span><span class="p">(</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">b</span> <span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span> <span class="k">class</span> <span class="nc">T2</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">N</span> <span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">swap</span><span class="p">(</span> <span class="n">T2</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">)[</span><span class="n">N</span><span class="p">],</span> <span class="n">T2</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">b</span><span class="p">)[</span><span class="n">N</span><span class="p">]);</span>
</code></pre>
</div>

<p>The former version, generalized for arbitrary type T, is implemented by calling
the move constructor and move assignment of type T. A possible implementation
may be like:</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">template</span><span class="o">&lt;</span> <span class="k">class</span> <span class="nc">T</span> <span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">swap</span><span class="p">(</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">b</span> <span class="p">)</span> <span class="p">{</span>
    <span class="n">T</span> <span class="n">tmp</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">a</span><span class="p">));</span>   <span class="c1">// Move constructor of a
</span>    <span class="n">a</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>      <span class="c1">// Move assignment of b
</span>    <span class="n">b</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>      <span class="c1">// Move assignment of tmp
</span><span class="p">}</span>
</code></pre>
</div>

<p>In the example above, due to the lack of user-defined move constructor and move
assignment, the copy constructor and copy assignment is called instead. Considering
our copy assignment calls user-defined swap, the user-defined swap will be
called twice if we apply the std::swap function to swap two User objects,
causing unnecessary overhead. Hence, whenever swapping two objects, the best
practice is to write <code class="highlighter-rouge">using std::swap</code> at first and then call the unqualified swap.</p>

<p>The latter version, specialized for array type T[N], is implemented by calling
the unqualified swap of T (which may be the user-defined swap or std::swap by
default) to swap each elements of the two arrays, rather than to swap the two
pointers directly. The operation to swap the elements of two arrays is done by
calling a more generalized version of swap for sequence called swap_ranges that
is used to swap two iterators, like <code class="highlighter-rouge">swap_ranges(a, a+N, b)</code>.</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="c1">// Defined in &lt;algorithm&gt;
</span><span class="k">template</span><span class="o">&lt;</span> <span class="k">class</span> <span class="nc">ForwardIt1</span><span class="p">,</span> <span class="k">class</span> <span class="nc">ForwardIt2</span> <span class="o">&gt;</span>
<span class="n">ForwardIt2</span> <span class="n">swap_ranges</span><span class="p">(</span> <span class="n">ForwardIt1</span> <span class="n">first1</span><span class="p">,</span> <span class="n">ForwardIt1</span> <span class="n">last1</span><span class="p">,</span> <span class="n">ForwardIt2</span> <span class="n">first2</span> <span class="p">);</span>
<span class="c1">// Omit the execution policy version for brevity.
</span></code></pre>
</div>

<p>Hence, <strong>the time complexity of swapping two arrays is O(N)</strong>. If swapping two
pointers is enough in practice, you have to write your own swap operation
instead of calling std::swap on them.</p>

<p>Furthermore, let’s look at the last generalized swap in the swap family that is
used on two iterators (or pointers, which the iterators resembles).</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="c1">// Defined in &lt;algorithm&gt;
</span><span class="k">template</span><span class="o">&lt;</span> <span class="k">class</span> <span class="nc">ForwardIt1</span><span class="p">,</span> <span class="k">class</span> <span class="nc">ForwardIt2</span> <span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">iter_swap</span><span class="p">(</span> <span class="n">ForwardIt1</span> <span class="n">a</span><span class="p">,</span> <span class="n">ForwardIt2</span> <span class="n">b</span> <span class="p">);</span>
<span class="c1">// Omit the execution policy version for previty.
</span></code></pre>
</div>

<p>It simply swaps the objects that the iterators point to, like:</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">template</span><span class="o">&lt;</span> <span class="k">class</span> <span class="nc">ForwardIt1</span><span class="p">,</span> <span class="k">class</span> <span class="nc">ForwardIt2</span> <span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">iter_swap</span><span class="p">(</span> <span class="n">ForwardIt</span> <span class="n">a</span><span class="p">,</span> <span class="n">ForwardIt</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">;</span>
    <span class="n">swap</span><span class="p">(</span><span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="o">*</span><span class="n">b</span><span class="p">);</span>
<span class="p">}</span>
</code></pre>
</div>

<p>For those readers who are not familiar to iterators, you can simply regard them
as pointers. Don’t be afraid of them, for they are designed to work like pointers.</p>

<h2 id="do-swap-throws">Do swap throws?</h2>

<p>All the guarantee brought by copy-and-swap idiom is merely based on a plausible
assumption that swap never throws. Considering the implementation of swap
usually requires no memory allocation and complicated operations, it is
generally regarded as no-fail (even stronger than no-throw, for a function that
throws no exception may fail and report it by logging, for example). However,
the reality is subtler than this simple assumption.</p>

<p>Let’s take video memory as an example. Nowadays, most computers for scientific
computation are equipped with powerful video cards. To deliver the computation
task to GPU, the program have to copy the data from the mainboard memory to the
video memory at first. There is a situation that we are going to swap two
objects, one on the mainboard memory and the other on the video memory.
Meanwhile, only the contents of the objects should be changed, not the
positions, that is, after the swap, the content of the object on the mainboard
memory becomes the other while the the position of it still remains on the
mainboard memory, not being moved to the video memory, though the exact address
of the object may be modified. Such swap, inevitably, is related to copying
between devices, and hence, is more likely to fail in comparison to simply
interchanging two pointers on the same device.</p>

<p>Therefore, swap may fail, although the scenario is more complicated. And hence,
copy-and-swap is not versatile.</p>

<p>Curious readers who know the noexcept qualifier may have asked how we decide
whether or not a swap function is noexcept. The answer is, we don’t, but we
leave it to the compiler to decide by describing the condition on which the swap
function is noexcept, which is called noexcept specification. Further discussion
about noexcept specification of swap will be posted in another article, for it’s
not only related to the other swaps we call, and the way how allocators are
abstracted and implemented in STL. It’s easy to understand, but requires more
efforts.</p>

  </div>

</article>



      </div>
    </main>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">Tomatoast&#39;s Recipes <small><a href="/feed.xml">via RSS</a></small></h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li>
          
            Tomatoast
          
          </li>
          
          <li><a href="mailto:thomasbyding@gmail.com">thomasbyding@gmail.com</a></li>
          
          
          <li>
            <a href="https://github.com/thomasding"><span class="icon icon--github"><svg viewBox="0 0 16 16" width="16px" height="16px"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span><span class="username">thomasding</span></a>

          </li>
          
          
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <p>Advanced programming topics and interesting reviews.
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
