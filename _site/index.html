<!DOCTYPE html>
<html lang="en">

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>tding.in</title>
  <meta name="description" content="Covering instruction-level optimization, C++ features, best practices and so many other interesting topics.">

  <link rel="stylesheet" href="/assets/main.css">
  <link rel="canonical" href="http://tding.in/">
  <link rel="alternate" type="application/rss+xml" title="tding.in" href="/feed.xml">
  
  
</head>


  <body>

    <header class="site-header" role="banner">

  <div class="wrapper">

    <a class="site-title" href="/">tding.in</a>

    <nav class="site-nav">
      <span class="menu-icon">
        <svg viewBox="0 0 18 15" width="18px" height="15px">
          <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
          <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
          <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
        </svg>
      </span>

      <div class="trigger">
        
        
          
        
          
        
          
        
          
        
          
          <a class="page-link" href="/archive/">Archive</a>
          
        
          
          <a class="page-link" href="/tags/">Tags</a>
          
        
      </div>
    </nav>

  </div>

</header>


    <main class="page-content" aria-label="Content">
      <div class="wrapper">
        <div class="home">

  <ul class="post-list">
    
      <li>
        <span class="post-meta">Jan 15, 2017</span>

        <ul class="post-tags">
          
          <li><a href="/tags/#windows" class="post-tag">windows</a></li>
          
        </ul>

        <h2>
          <a class="post-link" href="/2017/01/15/the-pitfalls-in-dll-loading.html">The Pitfalls in DLL Loading</a>
        </h2>

        
        <div class="post-excerpt">
          <p>I’ve recently met a problem in migrating a Linux project to Windows, which worked well when being statically linked but resulted in a deadlock when being dynamically linked. Furthermore, the process was stuck before entering the main function, which led me to guess that it was the initialization code of the dynamic library that caused the deadlock.</p>


        </div>
        

      </li>
    
      <li>
        <span class="post-meta">Dec 25, 2016</span>

        <ul class="post-tags">
          
          <li><a href="/tags/#c++" class="post-tag">c++</a></li>
          
          <li><a href="/tags/#metaprogramming" class="post-tag">metaprogramming</a></li>
          
        </ul>

        <h2>
          <a class="post-link" href="/2016/12/25/type-traits.html">Type Traits</a>
        </h2>

        
        <div class="post-excerpt">
          <p>Only given a type <strong>T</strong> without any knowledge of how it is implemented, just as
we encounter in template programming, what question can we ask about it? Here
are some questions that you may ask:</p>

<ol>
  <li>Is it an integral type/array/class/function/enum/union?</li>
  <li>Is it a lvalue/rvalue reference or non-reference?</li>
  <li>Is it const/volatile qualified?</li>
  <li>If it is a reference, what type is the non-reference part?</li>
  <li>If it is a pointer, what type is the object it points to?</li>
  <li>Is it the same type as type <strong>U</strong>?</li>
  <li>Is it a copy/move constructible/assignable?</li>
</ol>

<p>STL provides a collection of utility templates, called <strong>type traits</strong>, to
answer these questions about what feature a specific type <strong>T</strong> has. They are
defined in the header file <strong>&lt;type_traits&gt;</strong>.</p>


        </div>
        

      </li>
    
      <li>
        <span class="post-meta">Dec 11, 2016</span>

        <ul class="post-tags">
          
          <li><a href="/tags/#python" class="post-tag">python</a></li>
          
        </ul>

        <h2>
          <a class="post-link" href="/2016/12/11/generator.html">Generator</a>
        </h2>

        
        <div class="post-excerpt">
          <p>Generator are powerful tools that make it easy and convenient to create
iterators with shorter and cleaner code. Perhaps seeming unfamiliar though, the
whole looping concept of Python is constructed on iterators.</p>

<p>An iterator can be regarded as a tool to traverse a group of objects in a
specific order. Any object can be an iterator as long as it has a special member
function named <strong>__next__(self)</strong>. Each time <strong>__next__(self)</strong> is called, the
function returns the next accessible object to the caller, until there are no
more objects remaining to be iterated, at which time an exception
<strong>StopIteration</strong> is raised. Python provides a built-in function called
<strong>next(obj)</strong> that calls the <strong>__next__</strong> method of the given <strong>obj</strong>.</p>


        </div>
        

      </li>
    
      <li>
        <span class="post-meta">Dec 4, 2016</span>

        <ul class="post-tags">
          
          <li><a href="/tags/#c++" class="post-tag">c++</a></li>
          
          <li><a href="/tags/#metaprogramming" class="post-tag">metaprogramming</a></li>
          
        </ul>

        <h2>
          <a class="post-link" href="/2016/12/04/sfinae-conditionally-instantiating-function-templates.html">SFINAE: Conditionally Instantiating Function Templates</a>
        </h2>

        
        <div class="post-excerpt">
          <p>When we want to provide different implementations of a function according to the
type of the arguments, function overloading is the most usual way. When more
than one implementations match the types of the given arguments, the compiler
will choose the one that matches the most specifically. For example, the
function that accepts a pointer to the derived class is more specific than one
that accepts a pointer to the base class. One that accept the exact type is more
specific than one that needs implicit type conversion. Furthermore, in C++11, a
function can even overload on whether the argument is a lvalue reference or a
rvalue reference.</p>

<p>However, function overloading cannot handle all the cases. For example, when
defining a function template, it is impossible to enumerate all the types of the
arguments, so function overloading cannot be used. On the other hand, though
partial specialization can provide different implementations according to the
category of the given type, it can only be used in very limited situations where
the difference lies in whether or not the given type is a pointer, reference,
array or const/volatile-qualified.</p>

<p>Hence, we need more powerful mechanism to provide diverse implementations based
on the types of the arguments. That mechanism is <strong>SFINAE</strong>.</p>


        </div>
        

      </li>
    
      <li>
        <span class="post-meta">Nov 27, 2016</span>

        <ul class="post-tags">
          
          <li><a href="/tags/#c++" class="post-tag">c++</a></li>
          
        </ul>

        <h2>
          <a class="post-link" href="/2016/11/27/implementing-unique-ptr.html">Implementing unique_ptr</a>
        </h2>

        
        <div class="post-excerpt">
          <p><strong>unique_ptr</strong> is one of the best features of C++11. It is not only a necessity
at hand, but an exemplar of C++11 style programming. Unlike its cousin
<strong>shared_ptr</strong> and <strong>weak_ptr</strong>, <strong>unique_ptr</strong> is simple and free from
details about reference counting. Therefore, we are going to implement our own
<strong>unique_ptr</strong> in this post and show how to program with C++11.</p>


        </div>
        

      </li>
    
      <li>
        <span class="post-meta">Nov 20, 2016</span>

        <ul class="post-tags">
          
          <li><a href="/tags/#c++" class="post-tag">c++</a></li>
          
        </ul>

        <h2>
          <a class="post-link" href="/2016/11/20/unique-ptr-shared-ptr-and-weak-ptr.html">unique_ptr, shared_ptr and weak_ptr</a>
        </h2>

        
        <div class="post-excerpt">
          <p>Smart pointers are one of the most enchanting features that C++11 provides.
Using smart pointers, it’s possible that you will never need to remember freeing
a dynamically allocated object any more. However, C++11 provides three kinds of
smart pointers together. It’s important that you use the right one in practice.</p>


        </div>
        

      </li>
    
      <li>
        <span class="post-meta">Nov 5, 2016</span>

        <ul class="post-tags">
          
          <li><a href="/tags/#c++" class="post-tag">c++</a></li>
          
        </ul>

        <h2>
          <a class="post-link" href="/2016/11/05/move-and-forward.html">Move and Forward</a>
        </h2>

        
        <div class="post-excerpt">
          <p>One of the most confusing thing that one new to C++11 experiences is that
<strong>std::move</strong> actually never moves anything. All that it does is <strong>to cast a
reference type, whether a lvalue or rvalue reference, to a rvalue reference.</strong></p>

<p>By casting a reference to a rvalue (a call to a function that returns a rvalue
reference is a rvalue), the compiler will choose the <strong>A&amp;&amp;</strong> version if both the
<strong>const A&amp;</strong> and <strong>A&amp;&amp;</strong> version are provided. Usually, the version that
receives <strong>A&amp;&amp;</strong> moves (or steals) the underlying resource from the argument
instead of making a copy, so the function <strong>std::move</strong> semantically reveals its
usage rather than its behavior.</p>


        </div>
        

      </li>
    
      <li>
        <span class="post-meta">Oct 30, 2016</span>

        <ul class="post-tags">
          
          <li><a href="/tags/#c++" class="post-tag">c++</a></li>
          
        </ul>

        <h2>
          <a class="post-link" href="/2016/10/30/raii.html">RAII</a>
        </h2>

        
        <div class="post-excerpt">
          <p>RAII is a very important technique in C++, although its full name is a little
obscure: Resource Acquisition Is Initialization. While RAII can be briefly
described as: <strong>Bind a resource to an object, acquiring it in the constructor,
releasing it in the destructor, so that its life cycle is bound to that of the
object.</strong></p>

<p>To write a good RAII class, the following implementations should be <strong>avoided</strong>:</p>

<ol>
  <li>
    <p>to manually acquire or release the resource like open()/close()
method;</p>
  </li>
  <li>
    <p>to transfer the ownership of the resource by manual methods like move() or
transfer(), rather than move constructor or move assignment.</p>
  </li>
</ol>

<p>By conforming to RAII, many situations that introduces resource leaks can be
easily reduced, and at the same time, with clearer code.</p>


        </div>
        

      </li>
    
      <li>
        <span class="post-meta">Oct 26, 2016</span>

        <ul class="post-tags">
          
          <li><a href="/tags/#concurrency" class="post-tag">concurrency</a></li>
          
        </ul>

        <h2>
          <a class="post-link" href="/2016/10/26/forking-in-multi-threaded-programs-and-signal-handlers.html">Forking in Multi-threaded Programs and Signal Handlers</a>
        </h2>

        
        <div class="post-excerpt">
          <p>In Linux, forking in multi-threaded programs can be dangerous, even more in
signal handlers. Though the forked child process copies the address space of the
parent, only the caller thread is cloned into the child process, while all the
other threads get disappeared. When it comes to synchronization, if another
thread is holding a lock when the process forks, the lock will never be freed in
the child process, possibly also leaving the protected shared data in a
corrupted state.</p>

<p>Hence, thread-safe is not safe enough for a forked child process.</p>

<p>To be safely called in a child process, the function should be not only
thread-safe but async-signal-safe.</p>


        </div>
        

      </li>
    
      <li>
        <span class="post-meta">Oct 24, 2016</span>

        <ul class="post-tags">
          
          <li><a href="/tags/#c++" class="post-tag">c++</a></li>
          
        </ul>

        <h2>
          <a class="post-link" href="/2016/10/24/rvalue-reference.html">Rvalue Reference</a>
        </h2>

        
        <div class="post-excerpt">
          <p>Rvalue reference is a new feature introduced by C++11 that seems confusing at
first sight. After all, why do we need another reference type in the existence
of one already?</p>

<p>Briefly speaking, a rvalue reference is bound to a temporary object. By
contrast, a lvalue reference is bound to other objects. Besides, a lvalue
reference to const, such as const MyClass&amp;, can be bound to a temporary object,
too, which is the only way to bind to a temporary one prior to C++11.</p>

<p>But the explanation above says nothing about why we need a new reference type
specially for temporary objects. The simple way to explain it is: <strong>Lvalue and
rvalue references are used to overload a function so that the rvalue reference
version can be implemented based on the knowledge that the argument passed to it
is temporary.</strong></p>


        </div>
        

      </li>
    
      <li>
        <span class="post-meta">Oct 23, 2016</span>

        <ul class="post-tags">
          
          <li><a href="/tags/#python" class="post-tag">python</a></li>
          
          <li><a href="/tags/#concurrency" class="post-tag">concurrency</a></li>
          
        </ul>

        <h2>
          <a class="post-link" href="/2016/10/23/python-multiprocessing.html">Python Multiprocessing</a>
        </h2>

        
        <div class="post-excerpt">
          <p>Multiprocessing is an approach to improve performance by utilizing many CPUs in
Python. A C++ programmer is usually more familiar with multithreading, which
creates many worker threads to do the tasks in parallel. However, due to the
existence of GIL in Python, only one thread can run Python code at a time, when
other threads must wait for it to release the GIL, such as waiting for I/O
operations or mutexes. To achieve real parallelism, it is required to create
many processes rather than many threads. Thankfully, python package
<strong>multiprocessing</strong> provides easy-to-use API to create many processes and
communicate between them. Furthermore, the API of <strong>multiprocessing</strong> is similar
to <strong>multithreading</strong>, so that the same technique can be applied to
multithreading scripts as well.</p>


        </div>
        

      </li>
    
      <li>
        <span class="post-meta">Oct 21, 2016</span>

        <ul class="post-tags">
          
          <li><a href="/tags/#c++" class="post-tag">c++</a></li>
          
          <li><a href="/tags/#exception-safe" class="post-tag">exception-safe</a></li>
          
        </ul>

        <h2>
          <a class="post-link" href="/2016/10/21/vector-and-pop-back.html">Vector and pop_back</a>
        </h2>

        
        <div class="post-excerpt">
          <p>In vector, there is a function <strong>push_back</strong> that extends the vector size by 1
and put the object onto the last element, while there is no such function
<strong>pop_back</strong> that shrinks the size by 1 and returns the last element. As is
implemented by STL, vector provides function <strong>back</strong> to access the last element
and another function <strong>pop_back</strong> that shrinks the size by 1 but returns
nothing, respectively.</p>


        </div>
        

      </li>
    
      <li>
        <span class="post-meta">Oct 16, 2016</span>

        <ul class="post-tags">
          
          <li><a href="/tags/#c++" class="post-tag">c++</a></li>
          
          <li><a href="/tags/#exception-safe" class="post-tag">exception-safe</a></li>
          
        </ul>

        <h2>
          <a class="post-link" href="/2016/10/16/copy-and-swap.html">Copy and Swap</a>
        </h2>

        
        <div class="post-excerpt">
          <p>Copy-and-swap idiom is frequently used to implement a copy assignment operator.</p>

<p>If an exception is thrown during copy assignment, it may cause some data members
to remain unchanged while some others already assigned to new values. In
order to ensure that the object to be copied to be in the original value if an
exception is thrown, we first <strong>create a temporary object by calling its copy
constructor with the object to be copied from, and then swap the contents of the
temporary object with the destination object</strong>. Swap is required to be a
no-failure operation, that is, it always succeeds and never throws exceptions. 
Considering swap is always implemented by interchanging pointers and primitive
variables, it is easy to satisfy the requirement. If an exception is thrown in
the copy step, the temporary object is properly freed, and the destination
object keeps its original value.</p>


        </div>
        

      </li>
    
      <li>
        <span class="post-meta">Oct 12, 2016</span>

        <ul class="post-tags">
          
          <li><a href="/tags/#architecture" class="post-tag">architecture</a></li>
          
        </ul>

        <h2>
          <a class="post-link" href="/2016/10/12/reorder-buffer.html">Reorder Buffer</a>
        </h2>

        
        <div class="post-excerpt">
          <p>In the plain Tomasulo algorithm introduced by <a href="/2016/10/10/tomasulo-algorithm.html">Tomasulo Algorithm</a>, the
changes applied to the registers and memory may take place in any order. That
may cause inconsistent state in the case of an exception, in which the execution
can not be resumed after the exception is handled.
Using reorder buffer the changes are restricted to be applied in-order in spite
of the actual execution order inside the out-of-order execution unit.</p>


        </div>
        

      </li>
    
      <li>
        <span class="post-meta">Oct 10, 2016</span>

        <ul class="post-tags">
          
          <li><a href="/tags/#architecture" class="post-tag">architecture</a></li>
          
        </ul>

        <h2>
          <a class="post-link" href="/2016/10/10/tomasulo-algorithm.html">Tomasulo Algorithm</a>
        </h2>

        
        <div class="post-excerpt">
          <p>Tomasulo algorithm is an out-of-order execution policy. The philosophy of
Tomasulo algorithm is to execute an operation as soon as the required conditions
are satisfied in spite of the order of instructions.</p>


        </div>
        

      </li>
    
  </ul>

</div>

      </div>
    </main>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">tding.in <small><a href="/feed.xml">via RSS</a></small></h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li>
          
            Thomas Ding
          
          </li>
          
          <li><a href="mailto:thomasbyding@gmail.com">thomasbyding@gmail.com</a></li>
          
          
          <li>
            <a href="https://github.com/thomasding"><span class="icon icon--github"><svg viewBox="0 0 16 16" width="16px" height="16px"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span><span class="username">thomasding</span></a>

          </li>
          
          
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <p>Covering instruction-level optimization, C++ features, best practices and so many other interesting topics.
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
